<h1>今日のjava</h1>

 <div class="11月6日">
    package chap02;

    public class Code_2_1_2_15 {

	    public static void main(String[] args) {

		    int a;
    		int b;//①変数宣言の文
    		a = 20;//②計算の文（代入）
    		b = a + 5;//③計算の文（足し算して代入）。式と呼ぶ。
    		System.out.println(a);
            System.out.println(b);

            /*
              オペランド…上の「a」「b」「5」のことをいう。
              演算子………上の「+」「＝」のことをいう。
              ↑の全ての式はこの2つの要素だけで構成されています。
              リテラル……オペランドの中でも数字「5」や文字列「Hello World」など、ソースコードに
                          記述されている具体的な値のこと。データ型を持っています。
            */

            System.out.println("私の好きな記号は二重引用符(")です");//javaは前から文字列を認識するためエラーになる"

            System.out.println("私の好きな記号は二重引用符(\")です");
            /*
              \によってダブルクォーテーションは文字としてみなされる。
              \100を表示する場合、￥￥と二つつける。
             */
	    }

    }
 </div>
 <div class="11月7日">
          /*
          ★演算子は周囲のオペランドの情報を使って計算を行い、それらオペランドを巻き込んで結果に化ける。（置き換わる）
          ★式に演算子が複数ある場合は、javaで定められた優先順位の高い演算子から順に評価される。
          ★式の中に同じ優先順位グループに属する演算子が複数ある場合、演算子ごとに決められた「方向」から順に評価される。
          ★3.2/2＝1.6、9/2=4 「/」整数なのでint型。小数点は使えない。小数点の計算をする場合、9.0/2のようにどちらかの
          　オペランドを小数にする。小数にするとダブル型になり、結果が小数で表示される。
          代入演算子…右オペランドの内容を左オペランドの変数に代入する演算子。
          　　　　　　ex)
                         int a = 10
                         a += 5 (a = a+5)
                         a = 15
          単項演算子…++a、++bでは他の演算子と一緒に利用すると微妙に違っていて、実行されたときに表示されるものが変わる。
         */

        double d = 3;//double型変数にint型の3を代入できてしまう。
        String s = "ベスト" + 3;//String型とint型を連結出来てしまう。
        //Javaが式を評価する過程で自動的に型を変換しているからです。
        //ある型で宣言された変数には、その型の値しか代入出来ません。
        //値が自動的に箱の型に変換されて代入されます。
        //型のメモリーが小さいものから大きなものは変換できるが、逆は出来ない。
        float f = 3;//float型の変数にint型を代入
        double d = f;//double型の変数にfloat型を代入
        System.out.println(f);
        System.out.println(d);
        //意味的に「小さな型」の値を「大きな型」の箱に代入する場合、代入される値が代入先の変数の型
        //に自動的に変換されてから代入が行われる
        int i = 3.2;//小数はint型より大きいメモリーが必要なため代入できない
        //byte型やshort型の変数に対して、実害がない範囲でint型リテラルを代入することが例外で認められている。
        int age = (int)3.2;//強制的な型変換（キャスト変換）。3.2をintに型変換して代入せよという意味。
        System.out.println(age);
        //実行結果はint型はあくまで整数型のため小数点以下がなくなる。
        //キャスト演算子は、元のデータの一部を失ってもデータを強制的に変換しようとするため、はみ出た部分は捨てられてしまい、情報の欠損が発生します。
        //異なる型で演算を行った場合は、意味的に大きな型に統一されてから演算が行われる。
        double d = 8.5/2;//2(int型)を2.0(double型)に変換。
        long l = 5 + 2L;//5(int型)を5L(long型)に変換。
        String msg = "私の年齢は" + 23;//23(int型)が”23”(string型)に変換されて連結される。
        //命令実行の文とは…javaが準備してくれている様々な命令を呼び出すための文です。
        String name = "すがわら";//①変数宣言の文
        String message;//①変数宣言の文
        message = name + "さん、こんにちは";//②計算の文
        System.out.println(message);//命令実行の文。(message)は引数またはパラメーター。
        System.out.println();//printlnのlnはline。一行で表示される。
        System.out.print();//続けて表示される。
        int a = 5;
        int b = 3;
        int m = Math.max(a,b);//引数を比較してどちらか大きい数字がmに入る
        String age = "31";
        int n = Integer.parseInt(age);//string型をint型に変換する。
        int r = new java.util.random().nextInt(90);//0~89までの90通りの乱数
        String name = new java.util.Scanner(System.in).nextLine();//キーボードから文字列を受け取る
        int age = new java.util.Scanner(System.in).nextInt();//入力から文字列を受け取る。

 </div>
 <div class="11月8日">
       制御構造…文を実行させる順番のことをいう。（または制御フロー）
    		Thread.sleep(0);…1/1000秒で指定する。1000/1000=1秒。1秒間処理を止める。
    		制御構文…if文やwhile文のような制御構造を表す文のことを言う。
    		ブロック…ブロックとは複数の文をひとまとまりとして扱うものです。
    		　　　　　ブロック内が一文しかない場合、なみかっこを省略していい。
    		     　　　ブロック内で宣言した変数は、そのブロックが終わると同時に消滅します。
    		スコープ…変数が利用可能な範囲。
    		関係演算子…「＝＝」、「＞」など評価されて化けるという特性がある。
    		　　　　　　具体的には関係が成立するならtrue(真)に、そうでないならfalse(偽)に化ける。
    		String strA = "夕日";
    		メモリーの中の例3000番地に記録される。
    		strAに3000番地を記録して実際の3000番地に「夕日」を記録する。
    		strAが呼び出された場合、strAに記録されている番地から参照して呼び出す。
    		int型は変数に直接代入された数字が記録される(基本型)が、String型など頭文字が大文字のデータ型は記録されている番地
    		を参照してその番地から呼び出す（参照型）。
    		String strB = "夕日";

    		strA == strB
    		両方とも番地で登録されているため同じものだと認識されるが

    		String strC = new java.util.Scanner(system.in).nextLine();

    		strA == strB
    		の場合、newで強制的に新しいメモリー用域に記録されるため、別の番地が登録される。
    		そのため、同じ文字列でも別の文字列と認識されてしまう。

    		Str.equals…番地情報のひかくではなく、一文字一文字メモリーに記録されている文字を参照しているため、
    		　　　　　　同じ文字列か正確に出せる、

    		論理演算し…「＆＆」や「｜｜」のこと

    		switch文とは…すべての条件式が「変数＝＝値」や「変数＝＝変数」のような一致するかを比較するしきになっていて
    		　　　　　　　比較する値が小数や真偽値ではない。
    		       　　　条件に一致するcaseラベルまで処理をジャンプさせる命令。
    		          　　break文で明示的に「処理を中断してswitch文をぬける」という指示を出す。
    		break文…そのブロックをぬけるという意味。

    		前置判定…ブロックを実行する前に条件判定を行う。
    		　　　　　なので、初めから条件式の判定がfalseだった場合、一度もブロックが実行されない。
    		後置判定…ブロックを実行した後に条件判定を行う。
    		　　　　　　最低一回はブロックを実行する。
    		for文…繰り返しが始まるにあたり最初に一回だけ実行される文を初期化処理という。
    		　　　ここで使う変数を通常ループ変数という。
    		for(①初期化処理；②繰り返し条件；③繰り返し次処理)
    	　　ループ変数の名前は自由だが、一度宣言している変数は使えない。
    	  　変数はブロックの外に行くと消滅してしまう。

    	   多重構造のことをネストや入れ子という。

    	   continue文…今の周回を中断して同じ繰り返しの次の周回に進む。

    	   無限ループ…永久に繰り返しをし続ける制御構造のこと
</div>
<div class="11月10日">
        package chap04;

      　public class chap04_4_1_4_19 {

      	public static void main(String[] args) {

      		int sansu = 20;
      		int kokugo = 20;
      		int rika = 20;
      		int eigo = 20;
      		int syakai = 20;

      		int sum = sansu + kokugo + rika +syakai +eigo;

      		int avg = sum/5;

      		System.out.println("合計点:"+sum);
      		System.out.println("合計点:"+avg);

      		/*
      		  テスト科目が増えるたびに、それをコードに追加しなければならない
      		  まとめて処理ができない
      		  私たちは一組として計算できるが、javaは一つの箱として見ているのでまとめて見ることができない
      		*/

      		/*
      		  ある一定のルールにしたがってデータを格納する形式をデータ構造という
      		  その代表的なものが配列です。
      		  配列(array)とは同一種類の複数データを並び順で格納するデータ構造です。
      		  一つを要素年、配列の各要素には同一種類のデータしか格納できない。
      		  要素には番号がついていてそれを添え字（index）という。
      		  0~から始まる
      		*/

      	}

      	public static void code_1() {

      		int[] scores;//配列変数の宣言
      		scores = new int[5];//要素の作成と代入

      		/*
      		  int型の配列を５つ生成する(5つメモリーを準備する)
      		  int型は参照型ではなく、基本型のため普通はそのままメモリーに記録されるが
      		  配列のためString型のように参照される。
      		*/

      	}

      	public static void code_2() {

      		int[] scores = new int[5];//配列変数の宣言と要素の作成と代入を同時に行う

      		int num = scores.length;//配列の変数名.lengthで配列の要素数の取得
      		System.out.println("要素の数:"+num);

      	}

      	public static void code_3() {

      		int[] scores;
      		scores = new int[5];
      		scores[1] = 30;//2つめの要素に30を代入

      		System.out.println(sscores[1]);

      	}

      	public static void code_4() {

      		int x;

      		System.out.println(x);//xに何も値がない＝初期化をしていないためエラーがでる

      	}

      	public static void code_5() {

      		int[] scores = new int[5];

      		int[] scores1 = new int[] {20,30,40,50,80};//省略方法
      		int[] scores2 = {20,30,40,50,80};//省略方法2

      		System.out.println(scores[0]);

      		/*
      		  特に代入をしていなくても配列を作った時点で初期化され
      		  初期値の「0」の数字が入る。
      		  boolean型はfalse、string型はnullが初期値。
      		*/

      	}

      	public static void code_6() {

      		int[] scores = {20,30,40,50,80};
      		int sum = scores[1] + scores[2] + scores[3] + scores[4] + scores[5];
      	    int avg = sum / scores.length;

      		System.out.println("合計点:"+sum);
      		System.out.println("平均点:"+avg);

      		//要素数の添え字は0～4なのでコンパイルエラーとなる。

      	}

      	public static void code_7() {

      		int[] scores = {20,30,40,50,80};
      		for (int i = 0;i < scores.length; i++) {

      			System.out.println(scores[i]);//ループのたびにiの値が0～4で変化する

      		}

      	}

      	public static void code_8() {

      		int[] scores = {20,30,40,50,80};
      		int sum = 0;//集計結果を入れるための変数を初期化して準備
      		for (int i = 0;i < scores.length; i++) {

      			sum += scores[i];//1科目ずつ変数sumに合算する

      		}

      		int avg = sum /scores.length;

      		System.out.println("合計点:"+sum);
      		System.out.println("平均点:"+sum);

      	}

      	public static void code_9() {

      		int[] scores = {20,30,40,50,80};
      		int count = 0;//変数宣言と初期化
      		for (int i = 0; i < scores.length; i++) {

      			if(scores[i]>=50) {
      				count++;
      			}

      		}
      		System.out.println("50点以上の科目の数は:"+count);
      	}

      	public static void code_10() {

      		int[] seq = new int[10];

      		for(int i = 0; i< seq.length; i++) {

      			seq[1] = new fava.util.Random().nextInt(4);

      		}

      		for(int i = 0; i < seq.length; i++ ) {

      			switch([seq[i]]) {

      			case0:
      				System.out.println("A");
      			    break;
      			case1:
      			    System.out.println("T");
      			    break;
      			case2:
      			    System.out.println("G");
      			    break;
      			case3:
      			    System.out.println("C");
      			    break;

      		    }

      		}

      		char[] base = {'A','T','G','C'};
      		System.out.println(base[seq[i]]+"");

      		int vaseType = seq[i];//i番目の数値を取得
      		char baseChar = base[baseType];//数値に対応する記号を取得
      		System.out.println(baseChar+"");//記号を画面に表示
      	}

      	public static void code_11() {

      		int[] scores = {20,30,40,50,80};

      		for(int i = 0; i< scores.length; i++) {

      			System.out.println(scores[i]);

      		}

      		for(int value : scores) {
      			System.out.println(value);
      		}
      		//任意の変数名に指定した変数に配列の要素の内容が格納されます。
      		//これを拡張for文という。

      	}

      	public static void code4_15() {

      		int[] arrayA = {1,2,3};
      		int[] arrayB;

      		arrayB = arrayA;//住所番号を代入している

      		arrayB[0] = 100;

      		System.out.println(arrayA[0]);

      		/*
      		最初の要素のアドレスが変数に記録されている
      		住所番号を代入しているので参照先の値が一緒になっている
      		先頭の番号がわかればあとはインデックス番号で呼び出せる
      		int[] scores = new int[5]のメモリー上の処理
      		①int型の要素を5つ持つ配列がメモリ上に作成される。
      		②int[]型の配列変数scoreがメモリ上に作成される。
      		③配列変数scoreに配列の戦闘要素のアドレスが記録される。
      		プログラムからscores[n]と指定されたら
      		①scoresから番地(8832)を取り出し、配列(先頭要素)をみつける。
      		②見つけた配列の先頭要素からn個後ろの要素の区画を読み書きする。
      		*/
      	}

      	public static void code_11() {

      		boolean judge = true;

      		if (judge == true) {

      			int[] array = {1,2,3};

      		}
      		/*
      		ifブロック内で配列を宣言しているので
      		ブロックを抜けたら消滅する。
      		一方で、newで確保された３つの要素は普通の変数ではないので、ブロックが
      		終了しても寿命は迎えません。
      		メモリ内のごみとなってメモリを圧迫してしまう。
      		javaには、ガベージコレクションという仕組みがあり、
      		度の変数からも参照されなくなったメモリ領域を自動的に探しだして片づけてくれます。
      		*/
      	}

      	public static void code_12() {

      		int[] array = {1,2,3};
      		array = null;
      		array[0] = 10;
      		/*
      		配列変数arrayにnullを代入すると住所番号が空になり、
      		値の参照先がなくなった状態になる。
      		このことを参照を切るという。
      		①int[]型などの参照型変数に代入すると、その変数はなにも参照しなくなる。
      		②int型などの基本型変数には代入することはできない。
      		*/

      	}

      }

</div>
<div class="11月11日">
    package chap05;

        import java.net.http.HttpRequest.BodyPublisher;
        import java.security.PublicKey;

        public class code_5_1_5_14 {

        	public static void main(String[] args) {

        		/*
        		メソッドとは、複数の文をまとめ、それを1つの処理として名前をつけたもので部品の最小単位になります。
        		メソッド利用によるメリット
        		プログラムの見通しがよくなり、全体を把握しやすくなる。
        		機能単位に記述するため、修正範囲を限定できる。
        		同じ処理を一つのメソッドにまとめることで、作業効率が上がる。
        		メソッドを作成することをメソッドの定義という。
        		*/

        	}

        	public static void hello() {

        		System.out.println("湊さん、こんにちは");

        		//hello()はメソッド名です。｛｝のなかはメソッドブロックといい、hellメソッドを呼び出したときに実行される。
        		//メソッドを使用することをメソッドを呼び出すといいます。
        		//メソッド名は自由だが、基本的に動詞を使用する。

        		/*
        		mainメソッド内
        		System.out.println("メソッドを呼び出します");
        		hello();
        		System.out.println("メソッドを終了します");

        		helloメソッドを呼び出していてメソッドは自動的には動かない。
        		*/

        	}

        	public static void methodB () {

        		System.out.println("methodB");

        	}

        	public static void methodA() {

        		System.out.println("methodA");
        		methodB();

        	}
        	/*
        	ソースコード内に定義された各メソッドは同列の存在です。
        	プログラムは必ずmainメソッドから動き始める。
        	new java util Scanner(System.in).nextInt();はスキャナークラスのnextIntメソッドを
        	呼び出しているので「()」がある。
        	*/


        	public static void mein(String[] args) {

        		System.out.println("メソッドを呼び出します");

        		hello("湊");
        		hello("明日香");
        		hello("菅原");

        		System.out.println("メソッドの呼び出しが終わりました。");

        	}

        	public static void hello(String name) {

        		System.out.println(name+"さん、こんにちは");

        	}

        	public static void mein(String[] args) {

        		add(100,20);//100と20を渡してaddメソッドを呼び出す
        		add(200,50);//200と50を渡してaddメソッドを呼び出す

        	}

        	public static void add(int x,int y) {//int型を使っているため数字以外をうけつけない。変数2つのため使える数字も2つ。

        		int ans = x + y;
        		System.out.println(x + "+" + y + "=" + ans);

        	}

        	//渡す値、受け取る変数ともに「引数」だが、渡す値のことを実引数、受け取る変数のことを仮引数と呼びます。

        	public static void meein(String[] args) {

        		int x = 100;
        		int y = 10;
        		add();

        	}

        	public static void add() {

        		int ans = x + y;//ブロック外で宣言されているため変数は消滅してしまい、値が入らない。
        		System.out.println(x + "+" + y + "=" + ans);

        	}

        	//メソッド内で宣言した変数をローカル変数と呼び、別のメソッドに属する同名のローカル変数とはまったく別物です。
        	//異なるメソッドに属するローカル変数は、お互いに独立していて無関係である。

        	public static int add(int x,int y) {

        		int ans = x + y;
        		return ans;//型を一致させる。何も戻さない場合はvoidを指定します。
        		return文はメソッドの終了も行うのでreturnの後にコードを書くとコンパイルエラーになり、到達不能コードを教えてくれる。4221
        	}

        	public static void main(String[] args) {

        		int ans = add(100,10);
        		System.out.println("100+10="+ans);

        	}

    }

</div>
<div class="11月13日">
    package chap05;

    public class practice {

    	public static int add(int x,int y) {

    		return x + y;

    	}

    	public static double add(double x, double y) {

    		return x+ y;

    	}

    	public static String add(String x, String y) {

    		return x+ y;

    	}

    	public static void main(String[] args) {

    		System.out.println(add(10, 20));

    		System.out.println(add(3.5, 2.7));

    		System.out.println(add("Hello", "World"));

    	}

    	//同じ名前のメソッドをつけることをオーバーロードといいます。
    	//仮引数が異なれば同じ名前のメソッドをつけることが許されます。
    	//ＪＶＭが同じメソッドでも仮引数に合致するものを選んで実行してくれる。
    	//引数の個数も合致するものから選ばれる。
    	//メソッド宣言に記述するメソッド名、引数の個数や型とその並び順の情報をまとめて、メソッドのシグネチャといいます。
    	//オーバーロードは「シグネチャが重複しない場合のみ許される」


    	public static void printArray(int[] array) {

    		for(int element : array) {

    			System.out.println(element);

    		}

    	}

    	public static void maain(String[] args) {

    		int[] array = {1,2,3};

    		printArray(array);

    	}

    	//メソッドに引き渡している数字はメモリーに記録されている配列の値ではなく、変数に記録されている住所情報。
    	//値そのものが渡される呼び出しを値渡しと呼びます。
    	//引数としてアドレスを渡すことを参照渡しといいます。
    	/*
    	  基本形の変数をメソッド呼び出して渡すと
    	  ⑴呼び出し物の変数の内容が、呼び出し先の引数にコピーされる。
    	  ⑵呼び出し先で引数の内容を書き換えても、呼び出し元の変数は変化しない。
    	  参照渡しを行うと、呼び出し先で加えた変更が呼び出し元にも影響するようになる。
    	*/

    	public static void incArray(int[] array) {

    		for (int i= 0; i < array.length; i++) {

    			array[i]++;//要素に「+1」していてブロックをぬけるてもメモリーが書き変わったまま。

    		}

    	}

    	public static void maaain(String[] args) {

    		int[] array = {1,2,3};

    		incArray(array);

    		for(int i : array) {

    			System.out.println(i);

    		}

    	}

    	public static int[] makeArray(int size) {

    		int[] newArray = new int[size];//番地情報が造られた
    		for (int i = 0; i < newArray.length; i++) {

    			newArray[i] = i;

    		}

    		return newArray;//アドレスを返す

    	}

    	public static void maaaain(String[] args) {

    		int[] array = makeArray(3);

    		for(int i : array) {//返ってきた番地情報からメモリーを参照する

    			System.out.println(i);
    		}

    	}
    	/*
    	  javaプログラムを起動する際、プログラム起動時の追加情報のことをコマンドライン引数といいます。
    	  プログラム起動時に指定したコマンドライン引数が、JVMによって配列に変換され、mainメソッド起動時に渡される。
    	 */


    }

</div>
<div class="11月14日">
    package chap06;

public class Code6_1_6_10 {

	public static void main(String[] args) {

		int a = 10; int b = 2;

		int total = tasu(a,b);
		int delta = hiku(a,b);

		System.out.println("足すと"+total+"、引くと"+delta);

	}

	public static int tasu(int a,int b) {

		return(a+b);

	}

	public static int hiku(int a,int b) {

		return(a-b);

	}

	/*
	  複数のソースファイルに分けて開発するということは、複数のクラスに分けて開発することです。
	  ファイルごとに開発を分担し、それぞれが並行して開発を進められる(分業しやすい)。
	  このように、一つのプログラムを複数の部品に分けることを部品化という。
	  上記の３つのメソッドのうち、どれを別クラスに切り出すべきか。
	  ★計算処理メソッドを記述するためのソースファイルを作る
	  ソースファイル名とクラス名は同じでなければならない
	  ★tasu()とhiku()を移動させる
	  別クラスに移動させるとこのままでは呼び出せない。
	  int tatal = CalcLogic.tasu(a,b);
	  int delta = CalcLogic.hiku(a,b);
	  のようにcalclogicくらすのメソッドであることを明示的に所属を示す必要がある。
	  javaプログラムを誰かに渡す場合、複数のクラスファイルが入っているフォルダを丸ごと「一つの完成品」として渡す
	  ★javaプログラムの完成品は、複数のクラスファイルの集合体
	  ★誰かに配布する場合には、すべてのクラスファイルを渡す必要がある。
	  jvmは起動時に指定されたクラスの中にあるmainメソッドを呼び出してプログラムの実行を開始します。
	  よってプログラムを実行する人は「渡された複数のクラスファイルのうち、mainメソッドが含まれているクラスの名前」を指定する必要がある。
	  他人が作ったjavaプログラムの場合は、クラスファイルを受け取っても、「どのクラスの中にmainメソッドがあるか」がわからないと起動できない。
	  各クラスをパッケージというグループに所属させて分類管理ができる。
	  java.util.Random().nextInc();
	  パッケージ名.クラス名.メソッド名
	  違うパッケージのクラスやメソッドを使用する場合、名前を指定しないとエラーになる。
	  どのパッケージにも所属していない場合、無名パッケージまたはデフォルトパッケージに属していると表現する。
	  別のパッケージのクラスメソッドを呼び出す場合は、コードの頭にパッケージ名とクラスメソッド名が必要。
	  このパッケージ名を頭に付けた完全なクラス名のことを、完全限定クラス名や完全修飾クラス名または略してfqcnといいます。
	  FQCN文を何度も打つと入力に手間がかかるため、このような場合はimport文を書くことで入力の手間を軽減できる。
	  パッケージ内のパッケージでもクラス名だけでは呼び出せない。あくまでパッケージは独立した存在のイメージ。
	  import文があったら、「このソースコードに単にクラス名だけの記述があってもimport文にあるパッケージを参照してそこのクラスから呼び出せる」という指示。
	  import calcapp.logics.*で「*」があることでそのパッケージまたはクラスのすべてをimportできる。
	  javaでは一切の宣言なくJVMが扱えるすべてのクラスを常時使うことができるが、その利用に際しては必ずFQCNを利用しなければならない。
	  クラスローダー…完全限定名を指定されたら、その名前を持つクラスのクラスファイルをPCないから検索し、JVMに読み込んで利用可能にする。
	  JVMは使いたいクラス名を指定しているだけでクラスファイルがハードディスクのどこのフォルダにあるのかを、一切指定していない。
	  クラスローダーはクラスパスというヒント情報を使うことで高速に目的のクラスファイルを探す。
	  パッケージには、自分が作るクラスに対して、開発者が自由な名前をつけられるようにする側面もある。
	  内容が異なる別々のクラスで同じ名前を取り合うことを名前の衝突という。
	  使うことができること名前の総量（名前空間）は限られていて新しくクラスを作ると、そのクラス名は使えなくなり、使えるクラス名は減っていく。
	  パッケージが異なれば、同じクラス名を使ってよいというルールがある。
	  パッケージ名が異なれば、完全限定クラス名が異なるので両者を区別できるから。
	  私たちが作った一つのクラスがほかの数百個のクラスと連携して動く、多数のクラスからなるプログラムです。
	  javaに初めから標準添付されているクラスのことをAPI（application　programming　interface）と総称されます。
	  java.langパッケージに属するクラスは頻繁に利用するものが多いので、import文を記述しなくても自動的にインポートされる。
	  APIリファレンスとはAPIの説明書のこと。
	  javaのクラスローダーは必要なクラスだけを、必要になったときにロードするようにできている。」
	  */


}
</div>
<div class="11月15日">
    package chap07;

public class Code {

	/*
	  ソースコードが長くなってしまい、開発者自身がその内容を把握仕切れなくなることがある。
	  人間の頭g追いつかないために、人間自身がプログラム開発のボトルネック担ってしまっている。
	  オブジェクト指向プログラミングという考え方によって、大規模名プログラムもラクに開発できるようになりました。
	  人間が把握しきれない複雑さを克服するためにオブジェクト指向は生まれた。
	  オブジェクト指向とは、ソフトウェアを開発するときに用いる部品化の考え方。
	  私たちが開発するシステムやプログラムは、現実世界における何らかの活動を自動化するためのものです。
	  現実世界とは無関係に単独で存在している物は、ほとんどありません。
	  オブジェクト指向における部品化のルール
	  現実世界に出てくる登場人物の単位で、プログラムをクラスに分割する。
	  手順を一行一行さだめるのではなく、オブジェクトをどう作るか、どのように連携させるかを意識しながら開発していく。
	  プログラム開発時に「手続きを想像して作る」必要はない。現実世界をお手本に、それを真似して作ればいい。
	  現実世界の登場人物に変化があった場合、対応する部品（クラス）を修正、交換すれば簡単にプログラムを修正できる。
	  現実世界の登場人物たちを、コンピュータの中の仮想世界にオブジェクトとして再現し、現実世界と同じように連携して動くようにプログラミングを作ること。
	  オブジェクト指向の本質は、現実世界の登場人物とその振る舞いを、コンピュータ内の仮想世界で再現する。
	  一人一人を部品と考え、それぞれの責務(役割や責任)を事前に割り当てたクラスとして作ります。
	  あとは選手オブジェクト自身が自分の役割を果たしながらほかのオブジェクトと連携して動いてくれます。
	  責務の割り当て
	  オブジェクト指向プログラミングでは、開発者はそれぞれの部品（クラス）に「責務」をプログラミングとして書き込む。
	  例えば、ATMの「受付」オブジェクトにも行動責任があり、「口座」は行動責任を負っていませんが、残高をしっかり記録しておくという「情報保持責任」を負っています。
	  情報保持（属性）と行動（操作）の責任を果たすためオブジェクトはあります。
	  属性は情報保持責任があり、操作には行動責任がある。
	  メインメソッドなどからオブジェクトの操作を呼び出すことを行動指示を送るともいえる
	  オブジェクト指向の本質はあくまで「現実世界を仮想世界に再現すること」です。
	  オブジェクト指向言語には、開発者がより安全により便利に実世界を模倣できるよう、文法などに専用の機能が準備されています。
	  オブジェクト指向の三大機能「継承」「多態性」「カプセル化」を利用することにより、便利で安全なプログラムを作ることができる。
	  継承…過去に作った部品を流用し、新しい部品を簡単に作れる機能。すでに「勇者」という部品があれば、空を飛べる「スーパー勇者」は簡単に開発できる。
	  多態性…似ている2つの部品を「同じようなもの」とみなし、「いいかげん」に利用できる機能。お化けキノコとオオコウモリでは厳密には攻撃の仕方が微妙に異なる。
	  　　　　違いを気にせず、どちらも「同じようなもの」とみなし、「戦う」操作で攻撃できる。
	  カプセル化…属性や操作を、一部の相手からは利用禁止にする機能。現実世界では、剣が勇者に「眠れ」という指示をだすことは、まずありえない。
	  　　　　　　眠る操作は、剣オブジェクトから呼べないようにしておいたほうが安全。
	  カプセル化…


	*/


}
</div>
<div class="11月16日">
	package chap08;

public class Code8_1_8_16 {
	/*
	  Javaではオブジェクトそのものを開発者が直接定義することは許されません。
	  オブジェクトが生み出される際に用いられる、オブジェクトの設計図であるクラスを定義できます。
	  ①クラスを定義して、②そのクラスに基づいてオブジェクトを生成する。
	  オブジェクトを複数作成する状況を考える。
	  １０００個の口座オブジェクトそれぞれに対して「属性として、残高・名義人・開設日があって…」という定義を繰り返す必要があります。
	  クラスから100個でも1000個でも必要な数だけオブジェクトを生み出すことができます。
	  クラスとオブジェクトはまったく違うものである。仮想世界の中で活躍するのは「オブジェクトだけ」であって、その金型であるクラスが仮想世界で活動することは基本ありません。
	  オブジェクトという用語は、ときどきクラスのことをさして使われることもある、かなりあいまいなもの。
	  インスタンスとは、メモリー上に生み出された実態のあるもの。
	  仮想世界で活躍するのはインスタンスであり、そのインスタンスを生み出すための金型がクラスである。
	  誰かから指示(操作の呼び出し)をもらうことで責任を果たすために動く。
	  javaプログラムの組成に必要なくらすたち
	  mainメソッドを含む、一つの「神様くらす」
	  現実世界の登場人物を模した、複数の「登場人物のくらす」
	  あるクラスの設計内容を上から「クラス名」「属性」「操作」の一覧として並べる書き方は、クラス図というルールに準じたもの。
	  クラス図は世界共通の設計図として定義されたＵＭＬで定められた図のこと。
	*/
	/*
	public class Hero() {

		String name;
		int hp;

		public void attack() {
		}

		public void sleep() {

			this.hp = 100;//仮に引数があったとして、thisの記述がないとフィールドのhpではなく仮引数を持ってきてしまう。
			System.out.println(this.name+"は眠って回復した！");

		}

		public void sit(int sec) {
		}

		public void slip() {
		}

		public void run() {
		}

		/*
		   上から属性の定義＝フィールド、操作の定義＝メソッド
		   メソッド内で宣言してしまうと変数は消滅してしまう。クラスに直接記述することでどこのメソッドからでも使えるようになる。
		   フィールドの宣言は属性を宣言するには、クラスブロックの中に変数宣言を記述する。
		   フィールド宣言の先頭にfinalをつけると、値を書き換えることのできない定数フィールドになる。
		   操作の宣言方法
		   【名前】sleep←メソッド名
		   【必要情報】なし←引数
		   【結果】なし←戻り値
		   【処理内容】眠った後はHPが100に回復する
		   thisとは特別に用意された変数で自分自身のインスタンスを意味している。
		   thisがつくとフィールドを意味する
		   このクラスに所属するフィールドとメソッドはメンバと総称される。
		   クラス定義によって可能になる２つのこと
		   一つ目はそのクラスに基づいて、インスタンスを生成できるようになること。
		   二つ目はそのクラスから生まれたインスタンスを入れる変数の方が利用できるようになることです。
		   たとえば、ヒーロークラスを定義すると、hero型の変数が利用できるようになります。
		   このように、クラスを定義することで利用可能になる方のことをクラス型といいます。
		   javaで扱うすべての変数は必ず何らかの型を持っています。
		   整数を入れるためのint型や、文字列を入れるためのString型はjavaが標準で準備しており、いつでも使える型でした。
		   たとえば、Heroクラスを定義することで「Heroクラスから仮想世界に生み出されたインスタンスを入れることができるHero型」がつかえなくなります。
		   つまり、クラスを定義すればjavaで利用可能な型の種類はどんどん増えていく。
		   インスタンスは通常、クラス型変数に入れて利用する。
		   クラス型変数を用いる理由
		   仮想世界に複数存在しうる同名インスタンスの中から、特定の一つのインスタンスをプログラムとして識別するため。

		 */
	 	/*
		public class Main {

			public static void main(String[] args) {

				Hero h = new Hero();
				//クラス名　変数　＝　new クラス名();配列と同じように変数には先頭の番地情報しか入っていなく、先頭はフィールドに記載されている初めの宣言。
				h.name = "ミナト";
				h.hp = 100;
				//フィールドに初期値をセット
				System.out.println("勇者"+h.name+"を生み出しました");

				h.sit(5);
				h.slip();
				h.sit(25);
				h.run();

				//HPを増やしたり減らしたりという細かい計算処理や戦闘中画面にどのようなメッセージを出すかという細かい内容。
				//はメインメソッドに記述されていない。
				/*
				　開発者の都合や機能の単位に即してクラスやメソッドを作って来ました。
				　「オブジェクト指向」という明確な思想に基づいてクラスやメソッドが作られています。
				　現実世界と意味がつながったクラス
				　オブジェクト指向を意識したプログラム開発とは、現実世界の人やもの、出来事をクラスに置き換えていく作業にほかなりません。
				　現実に似せて作り、現実に似せて動かしていく、これがオブジェクト指向の根本的な思想です。
				*/

}
</div>
<div class="11月17日">
	package chap09;

public class Main {

	public static void main(String[] args) {
		
		//javaの仮想世界と表現してきたものは、実際には「コンピューターのメモリ領域です」
		//この領域は、javaのプログラムを実行する際に、JVMが大量にメモリ領域を使って準備するもので、ヒープといいます。
		//ヒープ領域はjavaを実行したときに確保されるメモリー領域
		//インスタンスとは「ヒープ領域の中に確保されたメモリ領域」に過ぎない
		//この右辺の実行結果とは、new によって生成されるインスタンスのために確保されたメモリの先頭番地です。
		//new Hero();によりインスタンスが生成されたので、変数hには3922という数値が代入されます。
		//ただ番地情報が入った箱がh変数で、アドレス情報を参照してメモリーに記録していく。（参照型）
		//フィールドへの値の代入
		//①変数hの内容を調べると、「3922番地を参照せよ」と書かれている。
		//②メモリ内の3922番地にあるインスタンスのメモリ領域にアクセスし、その中のhpフィールド部分を100に書き換える。
		//変数から番地情報を取り出し、次にその番地にアクセスするというJVMの動作を参照の解決やアドレス解決という。
		//同じクラスから生まれても異なるインスタンスであれば、互いに影響を受けないことをインスタンスの独立性といいます。
		//String str1 = "ミナト"
		//String str2 = "ミナト"はjavaが同じ文字列のことを認識し、変数に同じ番地情報が記録されるが、
		//String str3 = new String("ミナト")はnewを使用しているため新しいインスタンスが作られ文字列は同じだが番地情報が変わる。
		//newを使うと強制的にメモリーを作るため、新しいメモリーが作られる。（新しい番地情報が生成される）
		//クラス型は参照型だが配列の場合は、「int」ならint、「String」ならStringしかメモリーをとらないがクラスの場合、int,String,メソッドなど様々なメモリー領域を取りに行ける。
		//クラス型の変数には確保したメモリーの先頭のアドレスが入っている。
		//同じクラスからインスタンスを二つ生成する場合、メソッドはそのまま記録されているのではなく、メソッドがある場所のアドレスを記録していて、同じ番地情報が記録されているだけ。
		//同じメソッドを使用するため、二つ生成した場合、容量がもったいないのでメソッドはメソッドで別の領域に記録され実際にインスタンスに記録されているのは番地情報。
		//文字列を比較する場合、アドレス情報の比較（＝＝）にならないように、equalsをつかう。
		//newが一つしかないため仮想世界には一人の勇者しか誕生していない。
		//基本的にインスタンスを生み出す方法はnewしかない。
		//new実行時、例えばString型の名前は何文字記録されるかわからないため、番地情報が記録される。
		//あるクラスが別のクラスをフィールドとして利用している関係をhas-aの関係といいます。
		//勇者は剣を持っている
		//どの勇者を回復させるかを引数ｈとして受け取る
		//int型やdouble型の仲間ではなく、here型と同じ「クラス型」なのがString型です。
		//java.langパッケージに宣言されている。
		//java.langパッケージに所属するクラスを利用する場合、特例としてimport文を記述する必要がありません。
		//この特例のおかげで、本来「java.lang.String s;」と宣言する必要があるところを、単に「String s」と書けば利用できるようになっています。
		//二重引用符で文字列を囲めばインスタンスを生成して利用できる。
		//通常、インスタンスを生成するにはnew演算子を利用する必要があります。しかし文字列はプログラムの中で多様されるため、その都度newを書いていてはソースコードが長くなってしまうため。
		//Stringクラスはnewするとき、ついでに追加情報を指定できる特別な仕組みになっている。
		//newでインスタンスを生成した直後、必ずフィールドの初期値を代入しています。
		//なぜならnewで生み出されたばかりのインスタンスのフィールド（nameやhp）には、まだ何も入っていないからです。
		//javaではインスタンスが生まれた直後に自動実行される処理をあらかじめ定義できるようになる
		//インスタンス生成と同時にコンストラクタによってHPに100が代入される。
		//new Hero();の（）はコンストラクタのこと
		//命令文はメソッドに入れなければならないから、int hp;→hp = 30;はできない。
		//コンストラクタは、私たち開発者が直接よびだすものではない
		//Hero h = new Hero();はあくまでもインスタンスを生成することであって生成完了後にJVMがHero()を実行してくれます。
		//h.Hero();のように私たちが呼び出すことはできない。
		//インスタンス生成後に最初だけ自動的に呼ばれる。
		//コンストラクタとみなされる条件
		//①メソッド名がクラス名と完全に等しい
		//②メソッド宣言に戻り値の方が記述されていない(voidoもだめ)
		//newするときに渡した引数の型・数・順番に一致するコンストラクタが動作する（動作するコンストラクタは一つのみ）。
		//必ず何らかのコンストラクトを最初に実行するようになっていて
		//本来すべてのクラスは最低でも一つ以上のコンストラクタ定義を持っていなければなりません。
		//コンストラクタの特例
		//クラスに1つもコンストラクタが定義されていない場合に限って、「引数なし、処理内容なし」のコンストラクタ（デフォルトコンストラクタ）
		//がコンパイル時に自動的に追加される。
		//この特例によって引数なしコンストラクタがこっそり自動的に定義されたため、「new Hero();」によるインスタンス化が可能だったのです。
		//コンストラクトに同じ内容を書きたくなくてもthis.Hero("ダミー");とかけない。
		//なぜならコンストラクタを呼び出せるのはJVMだけだからです。
		//this(引数)でJVMにコンストラクタの起動を依頼することが可能
		//this.メンバ名は自分自身のインスタンスを表すが、this.(引数)は同一クラスのコンストラクタを呼び出すためのもの
		
		
		String t = new String("こんいちは");
		System.out.println(t);
		
		Sword s = new Sword();
		s.name = "炎の剣";
		s.damage = 10;
		
		Hero h1;//この段階ではHero型の箱が準備されるだけで、この箱には数値や文字列を入れることはできません。
		h1 = new Hero();//この行は右辺の実行結果がhに代入された状態。
		
		h1.hp = 100;
		h1.name = "ミナト";
		h1.sword = s;//swordフィールドに生成済みの剣インスタンスの番地を代入。
		
		System.out.println("現在の武器は"+h1.sword.name);
		
		Hero h2;
		h2 = new Hero();
		
		//h2 = h1;h1のアドレスを、h2のアドレスに入れる。
		h2.hp = 200;
		h2.name = "アスカ";
		
		Wizard w = new Wizard();
		
		w.name = "スガワラ";
		w.hp = 100;
		
		System.out.println(h1.hp);
		
		w.heal(h1);
		w.heal(h2);
		w.heal(h2);
		
		Hero h = new Hero("あすが");
		
		System.out.println(h.hp);
		System.out.println(h.name);
		
	}

}
package chap09;

public class Hero {	

	String name;
	int hp;
	Sword sword;
	
	public void attack() {
		
		System.out.println(this.name + "は攻撃した");
		System.out.println("敵に５ポイントのダメージを与えた");
		
	}
	
	public Hero() {//クラス名と同じ
		
		this.hp = 100;//newされた直後に自動的に実行される処理を書いたメソッドです。
	}
	//このクラスがnewされた直後に自動的に実行される
	//コンストラクタという。
	
	public Hero(String name) {
		
		this.hp = 100;
		this.name = name;
		
	}
	//これでnewするときに名前の初期値も指定できるように
	//コンストラクタに渡すべき引数をnewするときに指定します。
}
package chap09;

public class Sword {

	String name;
	int damage;
	
}
package chap09;

public class Wizard {

	String name;
	int hp;
	
	public void heal(Hero h) {
		
		h.hp += 10;
		System.out.println(h.name + "のHPを10回復した");
		
	}
	
	
	
}
</div>
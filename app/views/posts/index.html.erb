<h1>今日のjava</h1>

 <div class="11月6日">
    package chap02;

    public class Code_2_1_2_15 {

	    public static void main(String[] args) {

		    int a;
    		int b;//①変数宣言の文
    		a = 20;//②計算の文（代入）
    		b = a + 5;//③計算の文（足し算して代入）。式と呼ぶ。
    		System.out.println(a);
            System.out.println(b);

            /*
              オペランド…上の「a」「b」「5」のことをいう。
              演算子………上の「+」「＝」のことをいう。
              ↑の全ての式はこの2つの要素だけで構成されています。
              リテラル……オペランドの中でも数字「5」や文字列「Hello World」など、ソースコードに
                          記述されている具体的な値のこと。データ型を持っています。
            */

            System.out.println("私の好きな記号は二重引用符(")です");//javaは前から文字列を認識するためエラーになる"

            System.out.println("私の好きな記号は二重引用符(\")です");
            /*
              \によってダブルクォーテーションは文字としてみなされる。
              \100を表示する場合、￥￥と二つつける。
             */
	    }

    }
 </div>
 <div class="11月7日">
          /*
          ★演算子は周囲のオペランドの情報を使って計算を行い、それらオペランドを巻き込んで結果に化ける。（置き換わる）
          ★式に演算子が複数ある場合は、javaで定められた優先順位の高い演算子から順に評価される。
          ★式の中に同じ優先順位グループに属する演算子が複数ある場合、演算子ごとに決められた「方向」から順に評価される。
          ★3.2/2＝1.6、9/2=4 「/」整数なのでint型。小数点は使えない。小数点の計算をする場合、9.0/2のようにどちらかの
          　オペランドを小数にする。小数にするとダブル型になり、結果が小数で表示される。
          代入演算子…右オペランドの内容を左オペランドの変数に代入する演算子。
          　　　　　　ex)
                         int a = 10
                         a += 5 (a = a+5)
                         a = 15
          単項演算子…++a、++bでは他の演算子と一緒に利用すると微妙に違っていて、実行されたときに表示されるものが変わる。
         */

        double d = 3;//double型変数にint型の3を代入できてしまう。
        String s = "ベスト" + 3;//String型とint型を連結出来てしまう。
        //Javaが式を評価する過程で自動的に型を変換しているからです。
        //ある型で宣言された変数には、その型の値しか代入出来ません。
        //値が自動的に箱の型に変換されて代入されます。
        //型のメモリーが小さいものから大きなものは変換できるが、逆は出来ない。
        float f = 3;//float型の変数にint型を代入
        double d = f;//double型の変数にfloat型を代入
        System.out.println(f);
        System.out.println(d);
        //意味的に「小さな型」の値を「大きな型」の箱に代入する場合、代入される値が代入先の変数の型
        //に自動的に変換されてから代入が行われる
        int i = 3.2;//小数はint型より大きいメモリーが必要なため代入できない
        //byte型やshort型の変数に対して、実害がない範囲でint型リテラルを代入することが例外で認められている。
        int age = (int)3.2;//強制的な型変換（キャスト変換）。3.2をintに型変換して代入せよという意味。
        System.out.println(age);
        //実行結果はint型はあくまで整数型のため小数点以下がなくなる。
        //キャスト演算子は、元のデータの一部を失ってもデータを強制的に変換しようとするため、はみ出た部分は捨てられてしまい、情報の欠損が発生します。
        //異なる型で演算を行った場合は、意味的に大きな型に統一されてから演算が行われる。
        double d = 8.5/2;//2(int型)を2.0(double型)に変換。
        long l = 5 + 2L;//5(int型)を5L(long型)に変換。
        String msg = "私の年齢は" + 23;//23(int型)が”23”(string型)に変換されて連結される。
        //命令実行の文とは…javaが準備してくれている様々な命令を呼び出すための文です。
        String name = "すがわら";//①変数宣言の文
        String message;//①変数宣言の文
        message = name + "さん、こんにちは";//②計算の文
        System.out.println(message);//命令実行の文。(message)は引数またはパラメーター。
        System.out.println();//printlnのlnはline。一行で表示される。
        System.out.print();//続けて表示される。
        int a = 5;
        int b = 3;
        int m = Math.max(a,b);//引数を比較してどちらか大きい数字がmに入る
        String age = "31";
        int n = Integer.parseInt(age);//string型をint型に変換する。
        int r = new java.util.random().nextInt(90);//0~89までの90通りの乱数
        String name = new java.util.Scanner(System.in).nextLine();//キーボードから文字列を受け取る
        int age = new java.util.Scanner(System.in).nextInt();//入力から文字列を受け取る。

 </div>
 <div class="11月8日">
       制御構造…文を実行させる順番のことをいう。（または制御フロー）
    		Thread.sleep(0);…1/1000秒で指定する。1000/1000=1秒。1秒間処理を止める。
    		制御構文…if文やwhile文のような制御構造を表す文のことを言う。
    		ブロック…ブロックとは複数の文をひとまとまりとして扱うものです。
    		　　　　　ブロック内が一文しかない場合、なみかっこを省略していい。
    		     　　　ブロック内で宣言した変数は、そのブロックが終わると同時に消滅します。
    		スコープ…変数が利用可能な範囲。
    		関係演算子…「＝＝」、「＞」など評価されて化けるという特性がある。
    		　　　　　　具体的には関係が成立するならtrue(真)に、そうでないならfalse(偽)に化ける。
    		String strA = "夕日";
    		メモリーの中の例3000番地に記録される。
    		strAに3000番地を記録して実際の3000番地に「夕日」を記録する。
    		strAが呼び出された場合、strAに記録されている番地から参照して呼び出す。
    		int型は変数に直接代入された数字が記録される(基本型)が、String型など頭文字が大文字のデータ型は記録されている番地
    		を参照してその番地から呼び出す（参照型）。
    		String strB = "夕日";

    		strA == strB
    		両方とも番地で登録されているため同じものだと認識されるが

    		String strC = new java.util.Scanner(system.in).nextLine();

    		strA == strB
    		の場合、newで強制的に新しいメモリー用域に記録されるため、別の番地が登録される。
    		そのため、同じ文字列でも別の文字列と認識されてしまう。

    		Str.equals…番地情報のひかくではなく、一文字一文字メモリーに記録されている文字を参照しているため、
    		　　　　　　同じ文字列か正確に出せる、

    		論理演算し…「＆＆」や「｜｜」のこと

    		switch文とは…すべての条件式が「変数＝＝値」や「変数＝＝変数」のような一致するかを比較するしきになっていて
    		　　　　　　　比較する値が小数や真偽値ではない。
    		       　　　条件に一致するcaseラベルまで処理をジャンプさせる命令。
    		          　　break文で明示的に「処理を中断してswitch文をぬける」という指示を出す。
    		break文…そのブロックをぬけるという意味。

    		前置判定…ブロックを実行する前に条件判定を行う。
    		　　　　　なので、初めから条件式の判定がfalseだった場合、一度もブロックが実行されない。
    		後置判定…ブロックを実行した後に条件判定を行う。
    		　　　　　　最低一回はブロックを実行する。
    		for文…繰り返しが始まるにあたり最初に一回だけ実行される文を初期化処理という。
    		　　　ここで使う変数を通常ループ変数という。
    		for(①初期化処理；②繰り返し条件；③繰り返し次処理)
    	　　ループ変数の名前は自由だが、一度宣言している変数は使えない。
    	  　変数はブロックの外に行くと消滅してしまう。

    	   多重構造のことをネストや入れ子という。

    	   continue文…今の周回を中断して同じ繰り返しの次の周回に進む。

    	   無限ループ…永久に繰り返しをし続ける制御構造のこと
</div>
<div class="11月10日">
        package chap04;

      　public class chap04_4_1_4_19 {

      	public static void main(String[] args) {

      		int sansu = 20;
      		int kokugo = 20;
      		int rika = 20;
      		int eigo = 20;
      		int syakai = 20;

      		int sum = sansu + kokugo + rika +syakai +eigo;

      		int avg = sum/5;

      		System.out.println("合計点:"+sum);
      		System.out.println("合計点:"+avg);

      		/*
      		  テスト科目が増えるたびに、それをコードに追加しなければならない
      		  まとめて処理ができない
      		  私たちは一組として計算できるが、javaは一つの箱として見ているのでまとめて見ることができない
      		*/

      		/*
      		  ある一定のルールにしたがってデータを格納する形式をデータ構造という
      		  その代表的なものが配列です。
      		  配列(array)とは同一種類の複数データを並び順で格納するデータ構造です。
      		  一つを要素年、配列の各要素には同一種類のデータしか格納できない。
      		  要素には番号がついていてそれを添え字（index）という。
      		  0~から始まる
      		*/

      	}

      	public static void code_1() {

      		int[] scores;//配列変数の宣言
      		scores = new int[5];//要素の作成と代入

      		/*
      		  int型の配列を５つ生成する(5つメモリーを準備する)
      		  int型は参照型ではなく、基本型のため普通はそのままメモリーに記録されるが
      		  配列のためString型のように参照される。
      		*/

      	}

      	public static void code_2() {

      		int[] scores = new int[5];//配列変数の宣言と要素の作成と代入を同時に行う

      		int num = scores.length;//配列の変数名.lengthで配列の要素数の取得
      		System.out.println("要素の数:"+num);

      	}

      	public static void code_3() {

      		int[] scores;
      		scores = new int[5];
      		scores[1] = 30;//2つめの要素に30を代入

      		System.out.println(sscores[1]);

      	}

      	public static void code_4() {

      		int x;

      		System.out.println(x);//xに何も値がない＝初期化をしていないためエラーがでる

      	}

      	public static void code_5() {

      		int[] scores = new int[5];

      		int[] scores1 = new int[] {20,30,40,50,80};//省略方法
      		int[] scores2 = {20,30,40,50,80};//省略方法2

      		System.out.println(scores[0]);

      		/*
      		  特に代入をしていなくても配列を作った時点で初期化され
      		  初期値の「0」の数字が入る。
      		  boolean型はfalse、string型はnullが初期値。
      		*/

      	}

      	public static void code_6() {

      		int[] scores = {20,30,40,50,80};
      		int sum = scores[1] + scores[2] + scores[3] + scores[4] + scores[5];
      	    int avg = sum / scores.length;

      		System.out.println("合計点:"+sum);
      		System.out.println("平均点:"+avg);

      		//要素数の添え字は0～4なのでコンパイルエラーとなる。

      	}

      	public static void code_7() {

      		int[] scores = {20,30,40,50,80};
      		for (int i = 0;i < scores.length; i++) {

      			System.out.println(scores[i]);//ループのたびにiの値が0～4で変化する

      		}

      	}

      	public static void code_8() {

      		int[] scores = {20,30,40,50,80};
      		int sum = 0;//集計結果を入れるための変数を初期化して準備
      		for (int i = 0;i < scores.length; i++) {

      			sum += scores[i];//1科目ずつ変数sumに合算する

      		}

      		int avg = sum /scores.length;

      		System.out.println("合計点:"+sum);
      		System.out.println("平均点:"+sum);

      	}

      	public static void code_9() {

      		int[] scores = {20,30,40,50,80};
      		int count = 0;//変数宣言と初期化
      		for (int i = 0; i < scores.length; i++) {

      			if(scores[i]>=50) {
      				count++;
      			}

      		}
      		System.out.println("50点以上の科目の数は:"+count);
      	}

      	public static void code_10() {

      		int[] seq = new int[10];

      		for(int i = 0; i< seq.length; i++) {

      			seq[1] = new fava.util.Random().nextInt(4);

      		}

      		for(int i = 0; i < seq.length; i++ ) {

      			switch([seq[i]]) {

      			case0:
      				System.out.println("A");
      			    break;
      			case1:
      			    System.out.println("T");
      			    break;
      			case2:
      			    System.out.println("G");
      			    break;
      			case3:
      			    System.out.println("C");
      			    break;

      		    }

      		}

      		char[] base = {'A','T','G','C'};
      		System.out.println(base[seq[i]]+"");

      		int vaseType = seq[i];//i番目の数値を取得
      		char baseChar = base[baseType];//数値に対応する記号を取得
      		System.out.println(baseChar+"");//記号を画面に表示
      	}

      	public static void code_11() {

      		int[] scores = {20,30,40,50,80};

      		for(int i = 0; i< scores.length; i++) {

      			System.out.println(scores[i]);

      		}

      		for(int value : scores) {
      			System.out.println(value);
      		}
      		//任意の変数名に指定した変数に配列の要素の内容が格納されます。
      		//これを拡張for文という。

      	}

      	public static void code4_15() {

      		int[] arrayA = {1,2,3};
      		int[] arrayB;

      		arrayB = arrayA;//住所番号を代入している

      		arrayB[0] = 100;

      		System.out.println(arrayA[0]);

      		/*
      		最初の要素のアドレスが変数に記録されている
      		住所番号を代入しているので参照先の値が一緒になっている
      		先頭の番号がわかればあとはインデックス番号で呼び出せる
      		int[] scores = new int[5]のメモリー上の処理
      		①int型の要素を5つ持つ配列がメモリ上に作成される。
      		②int[]型の配列変数scoreがメモリ上に作成される。
      		③配列変数scoreに配列の戦闘要素のアドレスが記録される。
      		プログラムからscores[n]と指定されたら
      		①scoresから番地(8832)を取り出し、配列(先頭要素)をみつける。
      		②見つけた配列の先頭要素からn個後ろの要素の区画を読み書きする。
      		*/
      	}

      	public static void code_11() {

      		boolean judge = true;

      		if (judge == true) {

      			int[] array = {1,2,3};

      		}
      		/*
      		ifブロック内で配列を宣言しているので
      		ブロックを抜けたら消滅する。
      		一方で、newで確保された３つの要素は普通の変数ではないので、ブロックが
      		終了しても寿命は迎えません。
      		メモリ内のごみとなってメモリを圧迫してしまう。
      		javaには、ガベージコレクションという仕組みがあり、
      		度の変数からも参照されなくなったメモリ領域を自動的に探しだして片づけてくれます。
      		*/
      	}

      	public static void code_12() {

      		int[] array = {1,2,3};
      		array = null;
      		array[0] = 10;
      		/*
      		配列変数arrayにnullを代入すると住所番号が空になり、
      		値の参照先がなくなった状態になる。
      		このことを参照を切るという。
      		①int[]型などの参照型変数に代入すると、その変数はなにも参照しなくなる。
      		②int型などの基本型変数には代入することはできない。
      		*/

      	}

      }

</div>
<div class="11月11日">
    package chap05;

        import java.net.http.HttpRequest.BodyPublisher;
        import java.security.PublicKey;

        public class code_5_1_5_14 {

        	public static void main(String[] args) {

        		/*
        		メソッドとは、複数の文をまとめ、それを1つの処理として名前をつけたもので部品の最小単位になります。
        		メソッド利用によるメリット
        		プログラムの見通しがよくなり、全体を把握しやすくなる。
        		機能単位に記述するため、修正範囲を限定できる。
        		同じ処理を一つのメソッドにまとめることで、作業効率が上がる。
        		メソッドを作成することをメソッドの定義という。
        		*/

        	}

        	public static void hello() {

        		System.out.println("湊さん、こんにちは");

        		//hello()はメソッド名です。｛｝のなかはメソッドブロックといい、hellメソッドを呼び出したときに実行される。
        		//メソッドを使用することをメソッドを呼び出すといいます。
        		//メソッド名は自由だが、基本的に動詞を使用する。

        		/*
        		mainメソッド内
        		System.out.println("メソッドを呼び出します");
        		hello();
        		System.out.println("メソッドを終了します");

        		helloメソッドを呼び出していてメソッドは自動的には動かない。
        		*/

        	}

        	public static void methodB () {

        		System.out.println("methodB");

        	}

        	public static void methodA() {

        		System.out.println("methodA");
        		methodB();

        	}
        	/*
        	ソースコード内に定義された各メソッドは同列の存在です。
        	プログラムは必ずmainメソッドから動き始める。
        	new java util Scanner(System.in).nextInt();はスキャナークラスのnextIntメソッドを
        	呼び出しているので「()」がある。
        	*/


        	public static void mein(String[] args) {

        		System.out.println("メソッドを呼び出します");

        		hello("湊");
        		hello("明日香");
        		hello("菅原");

        		System.out.println("メソッドの呼び出しが終わりました。");

        	}

        	public static void hello(String name) {

        		System.out.println(name+"さん、こんにちは");

        	}

        	public static void mein(String[] args) {

        		add(100,20);//100と20を渡してaddメソッドを呼び出す
        		add(200,50);//200と50を渡してaddメソッドを呼び出す

        	}

        	public static void add(int x,int y) {//int型を使っているため数字以外をうけつけない。変数2つのため使える数字も2つ。

        		int ans = x + y;
        		System.out.println(x + "+" + y + "=" + ans);

        	}

        	//渡す値、受け取る変数ともに「引数」だが、渡す値のことを実引数、受け取る変数のことを仮引数と呼びます。

        	public static void meein(String[] args) {

        		int x = 100;
        		int y = 10;
        		add();

        	}

        	public static void add() {

        		int ans = x + y;//ブロック外で宣言されているため変数は消滅してしまい、値が入らない。
        		System.out.println(x + "+" + y + "=" + ans);

        	}

        	//メソッド内で宣言した変数をローカル変数と呼び、別のメソッドに属する同名のローカル変数とはまったく別物です。
        	//異なるメソッドに属するローカル変数は、お互いに独立していて無関係である。

        	public static int add(int x,int y) {

        		int ans = x + y;
        		return ans;//型を一致させる。何も戻さない場合はvoidを指定します。
        		return文はメソッドの終了も行うのでreturnの後にコードを書くとコンパイルエラーになり、到達不能コードを教えてくれる。4221
        	}

        	public static void main(String[] args) {

        		int ans = add(100,10);
        		System.out.println("100+10="+ans);

        	}

    }

</div>
<div class="11月13日">
    package chap05;

    public class practice {

    	public static int add(int x,int y) {

    		return x + y;

    	}

    	public static double add(double x, double y) {

    		return x+ y;

    	}

    	public static String add(String x, String y) {

    		return x+ y;

    	}

    	public static void main(String[] args) {

    		System.out.println(add(10, 20));

    		System.out.println(add(3.5, 2.7));

    		System.out.println(add("Hello", "World"));

    	}

    	//同じ名前のメソッドをつけることをオーバーロードといいます。
    	//仮引数が異なれば同じ名前のメソッドをつけることが許されます。
    	//ＪＶＭが同じメソッドでも仮引数に合致するものを選んで実行してくれる。
    	//引数の個数も合致するものから選ばれる。
    	//メソッド宣言に記述するメソッド名、引数の個数や型とその並び順の情報をまとめて、メソッドのシグネチャといいます。
    	//オーバーロードは「シグネチャが重複しない場合のみ許される」


    	public static void printArray(int[] array) {

    		for(int element : array) {

    			System.out.println(element);

    		}

    	}

    	public static void maain(String[] args) {

    		int[] array = {1,2,3};

    		printArray(array);

    	}

    	//メソッドに引き渡している数字はメモリーに記録されている配列の値ではなく、変数に記録されている住所情報。
    	//値そのものが渡される呼び出しを値渡しと呼びます。
    	//引数としてアドレスを渡すことを参照渡しといいます。
    	/*
    	  基本形の変数をメソッド呼び出して渡すと
    	  ⑴呼び出し物の変数の内容が、呼び出し先の引数にコピーされる。
    	  ⑵呼び出し先で引数の内容を書き換えても、呼び出し元の変数は変化しない。
    	  参照渡しを行うと、呼び出し先で加えた変更が呼び出し元にも影響するようになる。
    	*/

    	public static void incArray(int[] array) {

    		for (int i= 0; i < array.length; i++) {

    			array[i]++;//要素に「+1」していてブロックをぬけるてもメモリーが書き変わったまま。

    		}

    	}

    	public static void maaain(String[] args) {

    		int[] array = {1,2,3};

    		incArray(array);

    		for(int i : array) {

    			System.out.println(i);

    		}

    	}

    	public static int[] makeArray(int size) {

    		int[] newArray = new int[size];//番地情報が造られた
    		for (int i = 0; i < newArray.length; i++) {

    			newArray[i] = i;

    		}

    		return newArray;//アドレスを返す

    	}

    	public static void maaaain(String[] args) {

    		int[] array = makeArray(3);

    		for(int i : array) {//返ってきた番地情報からメモリーを参照する

    			System.out.println(i);
    		}

    	}
    	/*
    	  javaプログラムを起動する際、プログラム起動時の追加情報のことをコマンドライン引数といいます。
    	  プログラム起動時に指定したコマンドライン引数が、JVMによって配列に変換され、mainメソッド起動時に渡される。
    	 */


    }

</div>
<div class="11月14日">
    package chap06;

public class Code6_1_6_10 {

	public static void main(String[] args) {

		int a = 10; int b = 2;

		int total = tasu(a,b);
		int delta = hiku(a,b);

		System.out.println("足すと"+total+"、引くと"+delta);

	}

	public static int tasu(int a,int b) {

		return(a+b);

	}

	public static int hiku(int a,int b) {

		return(a-b);

	}

	/*
	  複数のソースファイルに分けて開発するということは、複数のクラスに分けて開発することです。
	  ファイルごとに開発を分担し、それぞれが並行して開発を進められる(分業しやすい)。
	  このように、一つのプログラムを複数の部品に分けることを部品化という。
	  上記の３つのメソッドのうち、どれを別クラスに切り出すべきか。
	  ★計算処理メソッドを記述するためのソースファイルを作る
	  ソースファイル名とクラス名は同じでなければならない
	  ★tasu()とhiku()を移動させる
	  別クラスに移動させるとこのままでは呼び出せない。
	  int tatal = CalcLogic.tasu(a,b);
	  int delta = CalcLogic.hiku(a,b);
	  のようにcalclogicくらすのメソッドであることを明示的に所属を示す必要がある。
	  javaプログラムを誰かに渡す場合、複数のクラスファイルが入っているフォルダを丸ごと「一つの完成品」として渡す
	  ★javaプログラムの完成品は、複数のクラスファイルの集合体
	  ★誰かに配布する場合には、すべてのクラスファイルを渡す必要がある。
	  jvmは起動時に指定されたクラスの中にあるmainメソッドを呼び出してプログラムの実行を開始します。
	  よってプログラムを実行する人は「渡された複数のクラスファイルのうち、mainメソッドが含まれているクラスの名前」を指定する必要がある。
	  他人が作ったjavaプログラムの場合は、クラスファイルを受け取っても、「どのクラスの中にmainメソッドがあるか」がわからないと起動できない。
	  各クラスをパッケージというグループに所属させて分類管理ができる。
	  java.util.Random().nextInc();
	  パッケージ名.クラス名.メソッド名
	  違うパッケージのクラスやメソッドを使用する場合、名前を指定しないとエラーになる。
	  どのパッケージにも所属していない場合、無名パッケージまたはデフォルトパッケージに属していると表現する。
	  別のパッケージのクラスメソッドを呼び出す場合は、コードの頭にパッケージ名とクラスメソッド名が必要。
	  このパッケージ名を頭に付けた完全なクラス名のことを、完全限定クラス名や完全修飾クラス名または略してfqcnといいます。
	  FQCN文を何度も打つと入力に手間がかかるため、このような場合はimport文を書くことで入力の手間を軽減できる。
	  パッケージ内のパッケージでもクラス名だけでは呼び出せない。あくまでパッケージは独立した存在のイメージ。
	  import文があったら、「このソースコードに単にクラス名だけの記述があってもimport文にあるパッケージを参照してそこのクラスから呼び出せる」という指示。
	  import calcapp.logics.*で「*」があることでそのパッケージまたはクラスのすべてをimportできる。
	  javaでは一切の宣言なくJVMが扱えるすべてのクラスを常時使うことができるが、その利用に際しては必ずFQCNを利用しなければならない。
	  クラスローダー…完全限定名を指定されたら、その名前を持つクラスのクラスファイルをPCないから検索し、JVMに読み込んで利用可能にする。
	  JVMは使いたいクラス名を指定しているだけでクラスファイルがハードディスクのどこのフォルダにあるのかを、一切指定していない。
	  クラスローダーはクラスパスというヒント情報を使うことで高速に目的のクラスファイルを探す。
	  パッケージには、自分が作るクラスに対して、開発者が自由な名前をつけられるようにする側面もある。
	  内容が異なる別々のクラスで同じ名前を取り合うことを名前の衝突という。
	  使うことができること名前の総量（名前空間）は限られていて新しくクラスを作ると、そのクラス名は使えなくなり、使えるクラス名は減っていく。
	  パッケージが異なれば、同じクラス名を使ってよいというルールがある。
	  パッケージ名が異なれば、完全限定クラス名が異なるので両者を区別できるから。
	  私たちが作った一つのクラスがほかの数百個のクラスと連携して動く、多数のクラスからなるプログラムです。
	  javaに初めから標準添付されているクラスのことをAPI（application　programming　interface）と総称されます。
	  java.langパッケージに属するクラスは頻繁に利用するものが多いので、import文を記述しなくても自動的にインポートされる。
	  APIリファレンスとはAPIの説明書のこと。
	  javaのクラスローダーは必要なクラスだけを、必要になったときにロードするようにできている。」
	  */


}
</div>
<div class="11月15日">
    package chap07;

public class Code {

	/*
	  ソースコードが長くなってしまい、開発者自身がその内容を把握仕切れなくなることがある。
	  人間の頭g追いつかないために、人間自身がプログラム開発のボトルネック担ってしまっている。
	  オブジェクト指向プログラミングという考え方によって、大規模名プログラムもラクに開発できるようになりました。
	  人間が把握しきれない複雑さを克服するためにオブジェクト指向は生まれた。
	  オブジェクト指向とは、ソフトウェアを開発するときに用いる部品化の考え方。
	  私たちが開発するシステムやプログラムは、現実世界における何らかの活動を自動化するためのものです。
	  現実世界とは無関係に単独で存在している物は、ほとんどありません。
	  オブジェクト指向における部品化のルール
	  現実世界に出てくる登場人物の単位で、プログラムをクラスに分割する。
	  手順を一行一行さだめるのではなく、オブジェクトをどう作るか、どのように連携させるかを意識しながら開発していく。
	  プログラム開発時に「手続きを想像して作る」必要はない。現実世界をお手本に、それを真似して作ればいい。
	  現実世界の登場人物に変化があった場合、対応する部品（クラス）を修正、交換すれば簡単にプログラムを修正できる。
	  現実世界の登場人物たちを、コンピュータの中の仮想世界にオブジェクトとして再現し、現実世界と同じように連携して動くようにプログラミングを作ること。
	  オブジェクト指向の本質は、現実世界の登場人物とその振る舞いを、コンピュータ内の仮想世界で再現する。
	  一人一人を部品と考え、それぞれの責務(役割や責任)を事前に割り当てたクラスとして作ります。
	  あとは選手オブジェクト自身が自分の役割を果たしながらほかのオブジェクトと連携して動いてくれます。
	  責務の割り当て
	  オブジェクト指向プログラミングでは、開発者はそれぞれの部品（クラス）に「責務」をプログラミングとして書き込む。
	  例えば、ATMの「受付」オブジェクトにも行動責任があり、「口座」は行動責任を負っていませんが、残高をしっかり記録しておくという「情報保持責任」を負っています。
	  情報保持（属性）と行動（操作）の責任を果たすためオブジェクトはあります。
	  属性は情報保持責任があり、操作には行動責任がある。
	  メインメソッドなどからオブジェクトの操作を呼び出すことを行動指示を送るともいえる
	  オブジェクト指向の本質はあくまで「現実世界を仮想世界に再現すること」です。
	  オブジェクト指向言語には、開発者がより安全により便利に実世界を模倣できるよう、文法などに専用の機能が準備されています。
	  オブジェクト指向の三大機能「継承」「多態性」「カプセル化」を利用することにより、便利で安全なプログラムを作ることができる。
	  継承…過去に作った部品を流用し、新しい部品を簡単に作れる機能。すでに「勇者」という部品があれば、空を飛べる「スーパー勇者」は簡単に開発できる。
	  多態性…似ている2つの部品を「同じようなもの」とみなし、「いいかげん」に利用できる機能。お化けキノコとオオコウモリでは厳密には攻撃の仕方が微妙に異なる。
	  　　　　違いを気にせず、どちらも「同じようなもの」とみなし、「戦う」操作で攻撃できる。
	  カプセル化…属性や操作を、一部の相手からは利用禁止にする機能。現実世界では、剣が勇者に「眠れ」という指示をだすことは、まずありえない。
	  　　　　　　眠る操作は、剣オブジェクトから呼べないようにしておいたほうが安全。
	  カプセル化…


	*/


}
</div>
<div class="11月16日">
	package chap08;

public class Code8_1_8_16 {
	/*
	  Javaではオブジェクトそのものを開発者が直接定義することは許されません。
	  オブジェクトが生み出される際に用いられる、オブジェクトの設計図であるクラスを定義できます。
	  ①クラスを定義して、②そのクラスに基づいてオブジェクトを生成する。
	  オブジェクトを複数作成する状況を考える。
	  １０００個の口座オブジェクトそれぞれに対して「属性として、残高・名義人・開設日があって…」という定義を繰り返す必要があります。
	  クラスから100個でも1000個でも必要な数だけオブジェクトを生み出すことができます。
	  クラスとオブジェクトはまったく違うものである。仮想世界の中で活躍するのは「オブジェクトだけ」であって、その金型であるクラスが仮想世界で活動することは基本ありません。
	  オブジェクトという用語は、ときどきクラスのことをさして使われることもある、かなりあいまいなもの。
	  インスタンスとは、メモリー上に生み出された実態のあるもの。
	  仮想世界で活躍するのはインスタンスであり、そのインスタンスを生み出すための金型がクラスである。
	  誰かから指示(操作の呼び出し)をもらうことで責任を果たすために動く。
	  javaプログラムの組成に必要なくらすたち
	  mainメソッドを含む、一つの「神様くらす」
	  現実世界の登場人物を模した、複数の「登場人物のくらす」
	  あるクラスの設計内容を上から「クラス名」「属性」「操作」の一覧として並べる書き方は、クラス図というルールに準じたもの。
	  クラス図は世界共通の設計図として定義されたＵＭＬで定められた図のこと。
	*/
	/*
	public class Hero() {

		String name;
		int hp;

		public void attack() {
		}

		public void sleep() {

			this.hp = 100;//仮に引数があったとして、thisの記述がないとフィールドのhpではなく仮引数を持ってきてしまう。
			System.out.println(this.name+"は眠って回復した！");

		}

		public void sit(int sec) {
		}

		public void slip() {
		}

		public void run() {
		}

		/*
		   上から属性の定義＝フィールド、操作の定義＝メソッド
		   メソッド内で宣言してしまうと変数は消滅してしまう。クラスに直接記述することでどこのメソッドからでも使えるようになる。
		   フィールドの宣言は属性を宣言するには、クラスブロックの中に変数宣言を記述する。
		   フィールド宣言の先頭にfinalをつけると、値を書き換えることのできない定数フィールドになる。
		   操作の宣言方法
		   【名前】sleep←メソッド名
		   【必要情報】なし←引数
		   【結果】なし←戻り値
		   【処理内容】眠った後はHPが100に回復する
		   thisとは特別に用意された変数で自分自身のインスタンスを意味している。
		   thisがつくとフィールドを意味する
		   このクラスに所属するフィールドとメソッドはメンバと総称される。
		   クラス定義によって可能になる２つのこと
		   一つ目はそのクラスに基づいて、インスタンスを生成できるようになること。
		   二つ目はそのクラスから生まれたインスタンスを入れる変数の方が利用できるようになることです。
		   たとえば、ヒーロークラスを定義すると、hero型の変数が利用できるようになります。
		   このように、クラスを定義することで利用可能になる方のことをクラス型といいます。
		   javaで扱うすべての変数は必ず何らかの型を持っています。
		   整数を入れるためのint型や、文字列を入れるためのString型はjavaが標準で準備しており、いつでも使える型でした。
		   たとえば、Heroクラスを定義することで「Heroクラスから仮想世界に生み出されたインスタンスを入れることができるHero型」がつかえなくなります。
		   つまり、クラスを定義すればjavaで利用可能な型の種類はどんどん増えていく。
		   インスタンスは通常、クラス型変数に入れて利用する。
		   クラス型変数を用いる理由
		   仮想世界に複数存在しうる同名インスタンスの中から、特定の一つのインスタンスをプログラムとして識別するため。

		 */
	 	/*
		public class Main {

			public static void main(String[] args) {

				Hero h = new Hero();
				//クラス名　変数　＝　new クラス名();配列と同じように変数には先頭の番地情報しか入っていなく、先頭はフィールドに記載されている初めの宣言。
				h.name = "ミナト";
				h.hp = 100;
				//フィールドに初期値をセット
				System.out.println("勇者"+h.name+"を生み出しました");

				h.sit(5);
				h.slip();
				h.sit(25);
				h.run();

				//HPを増やしたり減らしたりという細かい計算処理や戦闘中画面にどのようなメッセージを出すかという細かい内容。
				//はメインメソッドに記述されていない。
				/*
				　開発者の都合や機能の単位に即してクラスやメソッドを作って来ました。
				　「オブジェクト指向」という明確な思想に基づいてクラスやメソッドが作られています。
				　現実世界と意味がつながったクラス
				　オブジェクト指向を意識したプログラム開発とは、現実世界の人やもの、出来事をクラスに置き換えていく作業にほかなりません。
				　現実に似せて作り、現実に似せて動かしていく、これがオブジェクト指向の根本的な思想です。
				*/

}
</div>
<div class="11月17日">
	package chap09;

public class Main {

	public static void main(String[] args) {
		
		//javaの仮想世界と表現してきたものは、実際には「コンピューターのメモリ領域です」
		//この領域は、javaのプログラムを実行する際に、JVMが大量にメモリ領域を使って準備するもので、ヒープといいます。
		//ヒープ領域はjavaを実行したときに確保されるメモリー領域
		//インスタンスとは「ヒープ領域の中に確保されたメモリ領域」に過ぎない
		//この右辺の実行結果とは、new によって生成されるインスタンスのために確保されたメモリの先頭番地です。
		//new Hero();によりインスタンスが生成されたので、変数hには3922という数値が代入されます。
		//ただ番地情報が入った箱がh変数で、アドレス情報を参照してメモリーに記録していく。（参照型）
		//フィールドへの値の代入
		//①変数hの内容を調べると、「3922番地を参照せよ」と書かれている。
		//②メモリ内の3922番地にあるインスタンスのメモリ領域にアクセスし、その中のhpフィールド部分を100に書き換える。
		//変数から番地情報を取り出し、次にその番地にアクセスするというJVMの動作を参照の解決やアドレス解決という。
		//同じクラスから生まれても異なるインスタンスであれば、互いに影響を受けないことをインスタンスの独立性といいます。
		//String str1 = "ミナト"
		//String str2 = "ミナト"はjavaが同じ文字列のことを認識し、変数に同じ番地情報が記録されるが、
		//String str3 = new String("ミナト")はnewを使用しているため新しいインスタンスが作られ文字列は同じだが番地情報が変わる。
		//newを使うと強制的にメモリーを作るため、新しいメモリーが作られる。（新しい番地情報が生成される）
		//クラス型は参照型だが配列の場合は、「int」ならint、「String」ならStringしかメモリーをとらないがクラスの場合、int,String,メソッドなど様々なメモリー領域を取りに行ける。
		//クラス型の変数には確保したメモリーの先頭のアドレスが入っている。
		//同じクラスからインスタンスを二つ生成する場合、メソッドはそのまま記録されているのではなく、メソッドがある場所のアドレスを記録していて、同じ番地情報が記録されているだけ。
		//同じメソッドを使用するため、二つ生成した場合、容量がもったいないのでメソッドはメソッドで別の領域に記録され実際にインスタンスに記録されているのは番地情報。
		//文字列を比較する場合、アドレス情報の比較（＝＝）にならないように、equalsをつかう。
		//newが一つしかないため仮想世界には一人の勇者しか誕生していない。
		//基本的にインスタンスを生み出す方法はnewしかない。
		//new実行時、例えばString型の名前は何文字記録されるかわからないため、番地情報が記録される。
		//あるクラスが別のクラスをフィールドとして利用している関係をhas-aの関係といいます。
		//勇者は剣を持っている
		//どの勇者を回復させるかを引数ｈとして受け取る
		//int型やdouble型の仲間ではなく、here型と同じ「クラス型」なのがString型です。
		//java.langパッケージに宣言されている。
		//java.langパッケージに所属するクラスを利用する場合、特例としてimport文を記述する必要がありません。
		//この特例のおかげで、本来「java.lang.String s;」と宣言する必要があるところを、単に「String s」と書けば利用できるようになっています。
		//二重引用符で文字列を囲めばインスタンスを生成して利用できる。
		//通常、インスタンスを生成するにはnew演算子を利用する必要があります。しかし文字列はプログラムの中で多様されるため、その都度newを書いていてはソースコードが長くなってしまうため。
		//Stringクラスはnewするとき、ついでに追加情報を指定できる特別な仕組みになっている。
		//newでインスタンスを生成した直後、必ずフィールドの初期値を代入しています。
		//なぜならnewで生み出されたばかりのインスタンスのフィールド（nameやhp）には、まだ何も入っていないからです。
		//javaではインスタンスが生まれた直後に自動実行される処理をあらかじめ定義できるようになる
		//インスタンス生成と同時にコンストラクタによってHPに100が代入される。
		//new Hero();の（）はコンストラクタのこと
		//命令文はメソッドに入れなければならないから、int hp;→hp = 30;はできない。
		//コンストラクタは、私たち開発者が直接よびだすものではない
		//Hero h = new Hero();はあくまでもインスタンスを生成することであって生成完了後にJVMがHero()を実行してくれます。
		//h.Hero();のように私たちが呼び出すことはできない。
		//インスタンス生成後に最初だけ自動的に呼ばれる。
		//コンストラクタとみなされる条件
		//①メソッド名がクラス名と完全に等しい
		//②メソッド宣言に戻り値の方が記述されていない(voidoもだめ)
		//newするときに渡した引数の型・数・順番に一致するコンストラクタが動作する（動作するコンストラクタは一つのみ）。
		//必ず何らかのコンストラクトを最初に実行するようになっていて
		//本来すべてのクラスは最低でも一つ以上のコンストラクタ定義を持っていなければなりません。
		//コンストラクタの特例
		//クラスに1つもコンストラクタが定義されていない場合に限って、「引数なし、処理内容なし」のコンストラクタ（デフォルトコンストラクタ）
		//がコンパイル時に自動的に追加される。
		//この特例によって引数なしコンストラクタがこっそり自動的に定義されたため、「new Hero();」によるインスタンス化が可能だったのです。
		//コンストラクトに同じ内容を書きたくなくてもthis.Hero("ダミー");とかけない。
		//なぜならコンストラクタを呼び出せるのはJVMだけだからです。
		//this(引数)でJVMにコンストラクタの起動を依頼することが可能
		//this.メンバ名は自分自身のインスタンスを表すが、this.(引数)は同一クラスのコンストラクタを呼び出すためのもの
		
		
		String t = new String("こんいちは");
		System.out.println(t);
		
		Sword s = new Sword();
		s.name = "炎の剣";
		s.damage = 10;
		
		Hero h1;//この段階ではHero型の箱が準備されるだけで、この箱には数値や文字列を入れることはできません。
		h1 = new Hero();//この行は右辺の実行結果がhに代入された状態。
		
		h1.hp = 100;
		h1.name = "ミナト";
		h1.sword = s;//swordフィールドに生成済みの剣インスタンスの番地を代入。
		
		System.out.println("現在の武器は"+h1.sword.name);
		
		Hero h2;
		h2 = new Hero();
		
		//h2 = h1;h1のアドレスを、h2のアドレスに入れる。
		h2.hp = 200;
		h2.name = "アスカ";
		
		Wizard w = new Wizard();
		
		w.name = "スガワラ";
		w.hp = 100;
		
		System.out.println(h1.hp);
		
		w.heal(h1);
		w.heal(h2);
		w.heal(h2);
		
		Hero h = new Hero("あすが");
		
		System.out.println(h.hp);
		System.out.println(h.name);
		
	}

}
package chap09;

public class Hero {	

	String name;
	int hp;
	Sword sword;
	
	public void attack() {
		
		System.out.println(this.name + "は攻撃した");
		System.out.println("敵に５ポイントのダメージを与えた");
		
	}
	
	public Hero() {//クラス名と同じ
		
		this.hp = 100;//newされた直後に自動的に実行される処理を書いたメソッドです。
	}
	//このクラスがnewされた直後に自動的に実行される
	//コンストラクタという。
	
	public Hero(String name) {
		
		this.hp = 100;
		this.name = name;
		
	}
	//これでnewするときに名前の初期値も指定できるように
	//コンストラクタに渡すべき引数をnewするときに指定します。
}
package chap09;

public class Sword {

	String name;
	int damage;
	
}
package chap09;

public class Wizard {

	String name;
	int hp;
	
	public void heal(Hero h) {
		
		h.hp += 10;
		System.out.println(h.name + "のHPを10回復した");
		
	}
	
	
	
}
</div>
<div class="11月18日">
	package chap10;

public class Hero {

	String name;
	int hp = 100;
	
	public void attack(Matango s) {
		
		System.out.println(this.name+"の攻撃");
		
		s.hp -= 5;
		
		System.out.println("5ポイントのダメージを与えた");
		
	}
	
	public void run() {
		
		System.out.println(this.name+"は逃げ出した");
		
	}
	
	public final void slip() {
		
		this.hp -= 5;
		
		System.out.println(this.name+"は転んだ");
		System.out.println("5のダメージ");
		
	}
	
	public Hero() {
		
		System.out.println("ヒーロークラスのコンストラクタが起動しました");
		
	}
	
	
}
package chap10;

public class Item {

	String name;
	int price;
	
	public Item(String name) {
		
		this.name = name;
		this.price = 0;
		
	}
	
	public Item(String name,int price) {
		
		this.name = name;
		this.price = price;
		
	}
	
	
	
}
package chap10;

public class Matango {

	String name;
	int hp;
	
}
package chap10;

public class SuperHero extends Hero {

	boolean flying;
	
	public void attack(Matango s) {
		
//		System.out.println(this.name+"の攻撃");
//		s.hp -= 5;
//		System.out.println("5ポイントのダメージを与えた");
//		
//		if(this.flying) {
//			
//			System.out.println(this.name+"の攻撃");
//			s.hp += 5;
//			System.out.println("5ポイントのダメージを与えた");
		
		super.attack(s);
		if(this.flying) {
			
			super.attack(s);
			
		}
	
	}
	
	public void fly() {
		
		this.flying = true;
		System.out.println("飛び上がった");
		
	}
	
	public void land() {
		
		this.flying = false;
		System.out.println("着地した");
		
	}
	
	public void run() {
		
		System.out.println(this.name+"は逃げ出した");
		
	}
	
	public SuperHero() {
		
		System.out.println("スーパーヒーローのコンストラクタが起動");
		
	}
	
}
package chap10;

public class Weapon extends Item{
	
	public Weapon() {
		
		super("名無しの剣");
		
	}
	
}
package chap10;

public class Main {

	//以前作ったクラスとにかよったクラスを作る場合
	//同じようなクラスをいくつも作ると修正や追加に手間がかかる
	//把握も難しくなる
	//しかしjavaには、このようなコードの重複を懸念することなく類似したクラスを作ることができる機能「継承」がある。
	//extendsを使用すれば、親クラスを継承して子クラスができる。
	//superheroクラスのソースコードにはrun()がありませんが、インスタンス化されればrun()を呼び出すことができます。
	//extendsを利用してもととなるクラスの差分だけを記述して新たなクラスを宣言することができる。
	//このような２つのクラスの関係を継承関係といいます。
	//javaでは複数のクラスを親として多重継承を定義することを許していない。
	//親クラスを継承して子クラスを宣言する際に、親クラスのメンバを子クラス側で上乗せすることをオーバーライドといいます。
	//名前の似ているオーバーロードはメソッドの名前は一緒だけど引数が違うこと。	
	//①親クラスに同じメンバがなければそのメンバは追加になる。
	//②親クラスに同じメンバがあれば、そのメンバは上乗せされ上のものしか探されない。
	//superheroクラスにrun();を追加すると、javaは外側のメソッドから探しに行って見つかり次第処理を終了する。
	//オーバーライドを使用する場合、オーバーライドをわかりやすくするため@overrideをメソッドにつける
	//Stringクラス(java.lang.String)は、このクラスを継承してほかのクラスを作ってはいけませんと特別に指定されているクラス
	//javaでは宣言時にfinalがつけられているクラスは継承できないことになっている
	//宣言にfinalがつけられてメソッドは、子クラスでオーバーライドができない
	//フィールドはオーバーライドして使おうとしない
	//superheroはheroクラスのメンバを持っており二重構造になっている
	//インスタンスの外部からメソッドの実行依頼が届くと、多重構造のインスタンスは、極力、外側にある子インスタンス部分のメソッドで対応しようとします。
	//superheroインスタンスは内部にsuperheroとしての逃げ方とheroとしての逃げかたの両方を持っています。
	//親クラスのrun()には呼び出しが届かないため、子クラスのメソッドが呼ばれる。
	//将来親クラスのメソッドに変更が加えられた場合、オーバーライドに齟齬が出てしまう可能性がある。
	//super.を使って親インスタンスを呼び出すことで齟齬がでないようにできる
	//superとは今より一つ内側のインスタンス部分を表す予約語です。
	//親、子、孫クラスがいて、@overrideしたメソッドは孫から親をよびだせない
	//javaでは、すべてのコンストラクタは、その先頭で必ず内部のインスタンス部分（親クラス）のコンストラクタを呼び出さなければならない
	//本来superheroコンストラクタはsuper();の記述を入れなければならないが、コンパイラによって自動的に挿入される。
	//子クラスのコンストラクラを呼び出す場合、親クラスのコンストラクラも呼び出されるため引数がないとエラーになる。
	//子クラスのインストラクタに引数を指定することで解消される
	//正しい継承は「is aの原則」というルールにのっとっている継承のことです。
	//子クラス is a 親クラス(子クラスは親クラスの一種である)
	//is aの関係がない場合、現実世界と乖離してしまい、オブジェクト指向の原則から外れてしまいます。
	//正しい継承が行われている場合(is a)、子クラスになればなるほど具体的になる（特化）
	//親クラスになるほど抽象的であいまいなものに一般化（汎化）になる
	//継承関係を表す図を継承ツリーと呼ぶ
	//しかし継承は、ある二つのクラスに特化・汎化の関係があることを示すための道具でもある
	//矢印の先が一番抽象的になる
	
	public static void main(String[] args) {
		
		Hero h = new Hero();
		
		h.run();
		
		SuperHero sh = new SuperHero();
		
		sh.run();
		
		Weapon w = new Weapon();
		
		
	}
	
	
	
}
</div>
<div class="11月19日">
	package chap11;

public class Main {

	//あいまいなクラスたちの定義方法
	//これまで持っていたある意識を切り替える
	//高度な継承を使うときの「立場」が、これまでの「立場」とは全く違う
	//そのプログラムのためだけに必要なクラスを作って目的のプログラムを完成させる「立場」
	//継承を利用して子クラスを作る
	//クラスを事前に開発しておいてくれた開発者
	//現在、目の前のプログラム開発に必要なクラスを作る開発者（既存クラスを継承しこクラスを作る）
	//未来に備え、別の開発者が将来利用するであろうクラスを準備しておく開発者（親クラスとなるクラスを作っておく）
	//「抽象クラス」「インターフェイス」とは、「立場1の人たちに安全・便利に使ってもらえる親クラスを作る」ための道具です
	//「未来に備える開発者の」役割
	//他の開発者が効率よく安心して利用出来る継承の材料を作ること
	//キャラクタークラスを作っている時点では、まだアタックメソッドの内容を確定できないため、書きようがない
	//不都合⑴継承の材料となるクラスを作っている時点ではその処理内容をまだ確定できない詳細未定のメソッドが存在する
	//キャラクターは必ずアタックメソッドを持っているべき
	//現実世界に対応したメソッド定義の必要性
	//「現実世界の登場人物が持つ操作」であれば、クラスメソッドも存在するべきである（仮に、メソッドの処理内容は確定困難であったとしても）
	//アタックメソッドの中身を空にしておく
	//内容が空のアタックメソッドを受け継いでいるため、呼び出せるが、何も起きないという不具合に陥ってしまう
	//メソッドの中に何も書かないのはそもそも呼ばれても何もしないメソッドを作りたい場合に行う
	//しかし今回の場合は、何もしないのではなく、何をするかが未定で記述できない
	//この区別が就かない可能性がある
	//未来の開発者が間違ってキャラクタークラスをニューして利用してしまうかもしれないという心配です
	//キャラクタークラスは継承の材料として使うべきであってHeroやWizardみたいにnewして使うものじゃない
	//一部でも未完成部分が残っている設計図から、実体を生み出してはならない
	//そもそもnewされるべきではないクラス
	//キャラクタークラスのように詳細未定な部分が残っているクラスはインスタンス化されてはならない
	//ニューによる利用→インスタンスを生み出すためにそのクラスを利用する
	//エクステンドによる利用→別のクラスを開発する際、ゼロから作ると効率が悪いので、そのクラスを継承元として利用する。
	//開発者は以上二つの利用方法を選べる
	//abstractを使えば、現時点で処理内容を確定できないメソッドなのか何もしないメソッドなのかを確定できる
	//abstractとは、抽象的やあいまいという意味の英単語です。
	//abstractキーワードがつけられたメソッドは、抽象メソッドという
	//空のメソッドは何もしないメソッド、抽象メソッドは現時点では何をするかを確定できないメソッドとして区別できる
	//未完成部分を含む継承専用のクラスを誤ってnewされる可能性がある。
	//抽象クラスの制約は、ニューによるインスタンス化が禁止される
	//継承専用のクラスは抽象クラスとして宣言すれば、間違ってニューされることはない
	//抽象メソッドをオーバーライドしなければならない
	//隠れた抽象メソッドが潜んでいる
	//キャラクタークラスが持つすべてのメンバを継承している
	//ダンサークラス字体のソースコードに抽象メソッドはなくても、親クラスから抽象メソッドを継承して持っている
	//ダンサーは処理の内容が未確定なメソッドを持っている未確定なメソッドを持っているならばダンサークラスも抽象くらすにしなければならなi 
	//エラーの解消にはダンサークラスの宣言にabstractをつけて抽象クラスにするか内部の未完成部分を全部なくす
	//抽象クラスにするとコンパイルエラーは消えるが、インスタンス化が出来なくなる
	//
	
	public static void main(String[] args) {
		
		Hero h = new Hero();
		
		Matango m = new Matango();
		
		h.attack(m);
		
	}
}
</div>
<div class="11月20日">
	package chap11;

public class Main {

	//あいまいなクラスたちの定義方法
	//これまで持っていたある意識を切り替える
	//高度な継承を使うときの「立場」が、これまでの「立場」とは全く違う
	//そのプログラムのためだけに必要なクラスを作って目的のプログラムを完成させる「立場」
	//継承を利用して子クラスを作る
	//クラスを事前に開発しておいてくれた開発者
	//現在、目の前のプログラム開発に必要なクラスを作る開発者（既存クラスを継承しこクラスを作る）
	//未来に備え、別の開発者が将来利用するであろうクラスを準備しておく開発者（親クラスとなるクラスを作っておく）
	//「抽象クラス」「インターフェイス」とは、「立場1の人たちに安全・便利に使ってもらえる親クラスを作る」ための道具です
	//「未来に備える開発者の」役割
	//他の開発者が効率よく安心して利用出来る継承の材料を作ること
	//キャラクタークラスを作っている時点では、まだアタックメソッドの内容を確定できないため、書きようがない
	//不都合⑴継承の材料となるクラスを作っている時点ではその処理内容をまだ確定できない詳細未定のメソッドが存在する
	//キャラクターは必ずアタックメソッドを持っているべき
	//現実世界に対応したメソッド定義の必要性
	//「現実世界の登場人物が持つ操作」であれば、クラスメソッドも存在するべきである（仮に、メソッドの処理内容は確定困難であったとしても）
	//アタックメソッドの中身を空にしておく
	//内容が空のアタックメソッドを受け継いでいるため、呼び出せるが、何も起きないという不具合に陥ってしまう
	//メソッドの中に何も書かないのはそもそも呼ばれても何もしないメソッドを作りたい場合に行う
	//しかし今回の場合は、何もしないのではなく、何をするかが未定で記述できない
	//この区別が就かない可能性がある
	//未来の開発者が間違ってキャラクタークラスをニューして利用してしまうかもしれないという心配です
	//キャラクタークラスは継承の材料として使うべきであってHeroやWizardみたいにnewして使うものじゃない
	//一部でも未完成部分が残っている設計図から、実体を生み出してはならない
	//そもそもnewされるべきではないクラス
	//キャラクタークラスのように詳細未定な部分が残っているクラスはインスタンス化されてはならない
	//ニューによる利用→インスタンスを生み出すためにそのクラスを利用する
	//エクステンドによる利用→別のクラスを開発する際、ゼロから作ると効率が悪いので、そのクラスを継承元として利用する。
	//開発者は以上二つの利用方法を選べる
	//abstractを使えば、現時点で処理内容を確定できないメソッドなのか何もしないメソッドなのかを確定できる
	//abstractとは、抽象的やあいまいという意味の英単語です。
	//abstractキーワードがつけられたメソッドは、抽象メソッドという
	//空のメソッドは何もしないメソッド、抽象メソッドは現時点では何をするかを確定できないメソッドとして区別できる
	//未完成部分を含む継承専用のクラスを誤ってnewされる可能性がある。
	//抽象クラスの制約は、ニューによるインスタンス化が禁止される
	//継承専用のクラスは抽象クラスとして宣言すれば、間違ってニューされることはない
	//抽象メソッドをオーバーライドしなければならない
	//隠れた抽象メソッドが潜んでいる
	//キャラクタークラスが持つすべてのメンバを継承している
	//ダンサークラス字体のソースコードに抽象メソッドはなくても、親クラスから抽象メソッドを継承して持っている
	//ダンサーは処理の内容が未確定なメソッドを持っている未確定なメソッドを持っているならばダンサークラスも抽象くらすにしなければならなi 
	//エラーの解消にはダンサークラスの宣言にabstractをつけて抽象クラスにするか内部の未完成部分を全部なくす
	//抽象クラスにするとコンパイルエラーは消えるが、インスタンス化が出来なくなる
	//それまで未定だったメソッドの内容を確定させることを実装（implements）すると表現することもあります。
	//abstract(未確定)からimplements(実装)することでインスタンスか出来るようになった
	//詳細未定なメソッドを抽象メソッドとして宣言すれば、未来の開発者にオーバーライドを強制できる
	//全ての抽象メソッドを実装しなければクラス宣言からabstractを外すことは許されず、つまりnewして利用することは出来ません。
	//普通のクラスも抽象クラスも継承で特化と汎化の関係を表していることには変わらない
	//モンスターとキャラクター共通の親として先頭に参加する生き物を定義します。先頭に参加する生き物の中には、専守防衛的な生き物もいるかもしれませんのでattack()は定義できません。
	//バトルクリーチャーの親として生き物を定義します。これは村人やお姫様のように先頭に参加しない登場人物も含んでいるため、HPフィールドはあるとは限りませんが、どのような生き物であっても脅威から逃げるためのrun()はもっています。
	//もはや逃げるためのrunぐらいは最低でも持っているということしか決められない
	//抽象メソッドが増える。内容は確定できないが、一応存在するという抽象メソッドが現れ始めます。
	//抽象メソッドやフィールドが減っていく。クラスに定義してある抽象メソッドやフィールドが減っていきます。
	//継承階層を上にたどると、上流クラスは全て抽象クラスになります。
	//特に抽象度が高い抽象クラスをインターフェース(interface)として特別に扱うことができます
	//インターフェースとして特別扱いできる2つの条件
	//⑴全てのメソッドは抽象メソッドである
	//⑵基本的にフィールドを1つも持たない
	//インタフェイスに宣言されたメソッドは、自動的にpublicかつabstractになるというルールがあるので、省略してもいい
	//インターフェイスはクラスではなくインターフェイスというものになる
	//インターフェイスは基本的にフィールドを持たないが定数宣言だけは許される
	//インターフェイス内でフィールドを宣言すると自動的にpublic static finalが補われて定数を宣言したことになる
	//どのようにして洗うかというクリーニング店の内部で行われる作業については明かされていない
	//お客さんはメニューを見て、この仕事をお願いしますと依頼します。メニューはお客さんとの接点(interface)を表している
	//インタふえーすを継承して子クラスを定義する場合、extendsではなくimplementsを使います。
	//上記をインタフェースを実装してクラスを作るといいます。
	//実装する(implements)という用語が使われるのは、親インタフェースで未定だった各メソッドの内容をオーバーライドして実装し確定させるから
	//インターフェイスの効果
	//⑴同じインタフェイスをimplementsする複数の子クラスたちに、共通のメソッド群を実装するように強制出来る
	//⑵あるクラスがインタフェースを実装していれば、少なくともそのインタフェースが定めたメソッドは持っている事が保証される
	//インターフェイスは内部実装(メソッドの処理動作)を一切定めていません。
	//この性質のおかげでインタフェースでは特別に多重継承が許されています
	//普通のクラスで多重継承をもちいるとどちらを選択していいかわからない
	//インターフェイスなら親クラスが未確定メソッド同士なのでオーバーライドをすれば、何を選択すべきかわかる
	//クラスにはないインタフェイスの特権
	//異なる実装が衝突する問題が発生しないため、複数の親インタフェースによる多重継承が認められている。
	//オーバーライドをして処理の内容を確定しない場合、implements(実装)ではなくextends(拡張)をつかう
	
	
	public static void main(String[] args) {
		
		Hero h = new Hero();
		
		Matango m = new Matango();
		
		h.attack(m);
		
	}
}
</div>
<div class="11月21日">
	package chap12;

public class Main {

	//多態性のあいまいなイメージ
	//あるものをあえてザックリとらえることで、様々なメリットを享受しようという機能。
	//例えば、レンタカーを使用して車を運転する場合、厳密には初めて乗る車にもかかわらず、多くの人は問題なく運転できます。
	//細かいところは違うけど、ざっくり言えば同じ車だから運転できる
	//ざっくりとらえる方法が、オブジェクト指向三大機能の一つ、多態性なのです。
	
	
	
	
}
</div>
<div class="11月22日">
	ackage chap12;

public class Main {

	//多態性のあいまいなイメージ
	//あるものをあえてザックリとらえることで、様々なメリットを享受しようという機能。
	//例えば、レンタカーを使用して車を運転する場合、厳密には初めて乗る車にもかかわらず、多くの人は問題なく運転できます。
	//細かいところは違うけど、ざっくり言えば同じ車だから運転できる
	//ざっくりとらえる方法が、オブジェクト指向三大機能の一つ、多態性なのです。
	//character c = new superHero();はsuperheroのアドレスをcharacterクラスのcに入れている
    //本当はsuperheroインスタンスなのですが、あくまでもcharacterとしてとらえて利用することになる
	//あるインスタンスをどのようにとらえるかはどの型の変数に代入するか（箱の形）で決まります	
	//superheroがキャラクタークラスに入ることでjavaは基本的にキャラクターメンバを参照する
	//overrideしているメソッドはもともとあるメソッドの上に載っているのでjavaは外側から探しに行ってoverrideしているものをみつける
	//superheroモキャラクターの一種ですからキャラクターが入っていますという箱に入っていても別に矛盾はない
	//絵にかいてみてウソにならないインスタンスの代入は許されます
	//extendsやimplementsは開発者がis-aの関係をjavaに伝える手段
	//抽象クラスやインターフェイスの型
	//抽象クラスやインターフェイスからインスタンスを生み出すことはできないが、それらの型を利用することは可能
	//まったく同一である一つの存在に対して、複数の異なるとらえ方ができる
	//何かを利用する人はそれをなんととらえているかに利用方法が変わる
	//wizardはcharacterの箱に入っているためwizard独自のメソッドはcharacterをオーバーライドしているメソッドしかつかえない
	//wizardのフィールドも呼び出せなくなる
	//このキャラクター型にはいっているのはキャラクターの一種であるということだけ確実にいえる
	//attack（）が呼び出せた理由、箱の中身がheroでもwizardでもcharacterの一種であり、attackは継承して持っているはずだから(どんなキャラクターでも最低限、攻撃はできるから)
	//fireball()が呼び出せなかった理由。箱の中身がheroの場合など、fireball()を持っている職業とは限らないから(キャラクターであれば必ず火の玉を放てるとは限らないから)
	//キャラクターとして持つメソッドだけしか外部からは呼び出すことはできない
	//中身はあくまでもスライムなので、当然スライムが逃げます。
	//どんな型の箱に入っているかは関係ない
	//箱の型はどのメソッドを呼べるかを決定する
	//中身の型、メソッドが呼ばれたらどう動くかを決定する
	//コンパイラは基本的にプログラムを一行ずつ解釈・翻訳しようとする
	//キャスト演算をして無理やり代入する方法もあるか、ダウンキャストといわれる。
	//classcastExceptionは、キャストによる強制代入の結果ウソの構図になったので強制停止せざるを得ないくなったという意味
	//キャストしても大丈夫かチェックするinstanceof演算子がある
	//ざっくりとらえてモンスターならなんでも受け付けますという意味で
	//monsterクラスを継承しているslimeやgoblinなども攻撃できるようになる
	//厳密には異なるインスタンスをまとめて扱かうことができます
	//インスタンスは何型の箱に入っていようと自身の型のメソッドが動作する
	//呼び出し側は相手を同一視し、同じように呼び出すのに呼び出される側は、きちんと自分に決められた動きをするという特性から多態性という名前がついている
	public static void main(String[] args) {
		
		Wizard w = new Wizard();
		
		Character c = w;
		
		Matango m = new Matango();
	
		c.name = "アサカ";
		c.attack(m);
		c.run();
		
		//c.fireball(m);
		
		Slime s = new Slime();
		Monster o = new Slime();
		s.run();
		o.run();
		
		if(c instanceof Wizard) {
			
			Wizard h = (Wizard)c;
			h.fireball(m);
			
		}
		
		
		Hero h1 = new Hero();
		Hero h2 = new Hero();
		Thief t1 = new Thief();
		Wizard w1 = new Wizard();
		Wizard w2 = new Wizard();
		
		h1.hp += 50;
		h2.hp += 50;
		t1.hp += 50;
		w1.hp += 50;
		w2.hp += 50;
		
		Character[] z = new Character[5];
		
		z[0] = new Hero();
		z[1] = new Hero();
		z[2] = new Thief();
		z[3] = new Wizard();
		z[4] = new Wizard();
		
		for(Character ch : z) {
			
			ch.hp += 50;
			
		}
		
	
	}
		
}
</div>
<div class="11月23日">
	package chap13;

public class Main {

	//情報へのアクセスや動作の実施について、誰に何を許すかを定めて制限することをアクセス制限といいます。
	//Heroクラス以外からは勇者のHPフィールドに値を設定できない。
	//dieメソッドを呼べるのはHeroクラスだけである
	//カプセル化はこのようなアクセス制御を実現し、想定外に発生する不具合を未然に防ぐための仕組み
	//privateやpublicなどはアクセス修飾子と呼ばれ、フィールドやメソッドを宣言する際、先頭に記述することでアクセス制御が可能になります。
	//privateアクセス修飾はprivateであっても、自分のクラスからthis.~での読み書きは可能
	//メンバに関するアクセス修飾の定石
	//フィールドはすべてprivate、メソッドはすべてpublic
	//クラスは特に理由がない限りpublicで修飾するのが一般的です。
	//基本的にフィールドはメソッド経由でアクセスする
	//単にnameフィールドの中身を呼び出し元に返すだけの単純なメソッドです。このようなメソッドを総称してgetterメソッドといいます。
	//getterメソッドとは逆に、ある特定のフィールドに指定された値を代入するだけのメソッドをsetterメソッドといいます。
	//setterメソッドの場合、戻り値が要らないためvoid型を指定する
	//getterとsetterはアクセサと総称されることもある
	//Read Only、Write Onlyのフィールドを実現できる
	//フィールドの名前など、クラスの内部設計を自由に変更できる
	//フィールドへのアクセスを検査できる
	//throw new illegalargumentexceptionは今の段階ではエラーを出してプログラムが強制停止する命令と理解する
	//非publicクラスの特徴
	//⑴クラスの名前はソースファイル名と異なってもよい
	//⑵1つのソースファイルにクラスを複数宣言してもよい
	//カプセル化…あるクラスが外部から直接触られないよう、メソッドというカプセルによってフィールドが保護されているようにみえること
	//不具合とは、現実世界と仮想世界が食い違ってしまうことである
	public static void main(String[] args) {
		
		
		
		

	}

}

</div>
<div class="11月24日">
	package chap14;

public class Main {

	//すべてのクラスの親クラスがあるので、どの子クラスからもよべるメソッドがある
	//メソッドもフィールドも一切定義していないクラスのtoString()を呼び出せる
	//暗黙の継承
	//あるクラスを定義するとき、extendsで親クラスを指定しなければ、java.lang.Objectを親クラスとして継承したとみなされる
	//equals()あるインスタンスと自分自身とが同じか調べる
	//toString()自分自身の内容の文字列表現を返す
	//多態性を利用できるのでobject型の変数にはどんなインスタンスでも代入できる
	//object型の変数はあらゆる参照型のインスタンスを格納できるが基本データ型はできない。
	//すべてのクラスが最低限備えるべきメソッドを定義できるから
	//toStringが呼ばれたらどのフィールドの内容を、どう修飾して文字列表現にするかを指示させなければならない
	//「＝＝」を使った判定と「equals」を使った判定では、微妙にいみが異なることに注意が必要です。
	//前者のような比較は等値(equality)で後者は等価(equivalence)です
	//等値とは同一の存在であること
	//等価とは同じ内容であること
	//objectクラスのequalsメソッドは「＝＝」で設定されているため単純なアドレスの等値になっている
	//そもそも、等価かどうかは機械的に判定できない。なぜなら「なにをもって意味的に同じものとみなすか」は、クラスによって異なり、一律には決められないから
    //そのクラスのインスタンスについて、何を持って意味的に同じとみなすかをequals()のオーバーライドという形で指定しなければなりません
	//instanceofで変数にそのクラスを入れていいのか確認してもしtrueであれば、
	//this.name.equalsなどでstring型を呼び出し等価か判定させる
	//新しくクラスを開発したらtostring()とequals()をオーバーライドする必要性がないか確認する
	//静的メンバとは、staticmemberとも呼ばれstaticキーワードがつけられたフィールドやメソッドのことです。
	//フィールド変数の実態がクラスに準備される
	//静的フィールドの箱は個々のインスタンスごとに用意されるのではなく、クラスに対して一つだけ用意されます。
	//勇者の金型の上にmoneyの箱が準備されるイメージ
	//staticがついていればnewしなくてもjavaが実行したときにメモリーに確保される
	//メインメソッドにstaticがついていないとヒープ領域からみつからない
	//全インスタンスに、箱の分身が準備される
	//共通の箱がheroをインスタンス化しなくても用意されている
	//静的フィールドを用いればインスタンス間でフィールドを共有できる
	//インスタンスを一つも生み出さなくても共有の箱を利用可能になる
	//静的フィールドはクラス（金型）にフィールド（箱）が所属するという特徴からクラス変数といわれることもある
	//インスタンスに所属せずにクラスに所属している
	//多くの場合、staticやfinalやpublicと一緒に指定され、「変化しない定数を各インスタンスで共有するため」に利用されます
	//staticはフィールドもメソッドもnewを使わずともメモリーが確保される
	//Math.random()*1000はdouble型で返されるメソッドのため*1000をして整数にしている
	//静的メソッドまたはクラスメソッドと呼ばれ、静的メンバと総称されます。
	//メソッド自体がクラスに属するようになる
	//静的メソッドは、その実態が各インスタンスではなくクラスに属するため、クラス名を使って呼び出せるようになります。
	//インスタンスにメソッドの分身が準備される
	//インスタンスにも分身が作られるため、インスタンス変数名からも呼び出せる
	//インスタンスを一つも生み出すことなく呼び出せる
	//mainメソッドはstaticでなければならない理由が、javaはまずmainメソッドを探すのに、staticがないとメモリーが作られないから(newしないと)
	//同一クラス内のstaticがついていないフィールドやメソッドは利用できません。
	//静的メソッドは、まだ一つも勇者インスタンスが存在しない状況でも呼び出されることがあるメソッドです
	//ですから静的メソッド内部では、静的メンバしか利用できない
	//newせず手軽に呼び出すため
	//newではなく静的メソッドを使ってインスタンスを生成できる
	public static void main(String[] args) {

		Empty e = new Empty();
		String s = e.toString();
		
		System.out.println(s);
		
		Object o1 = new Empty();
		Object o2 = new Hero();
		Object o3 = "こんにちは";
		
		Hero h = new Hero();
		h.name = "ミナト";
		h.hp = 100;
		
		System.out.println(h.toString());
		
		Hero h1 = new Hero();
		h1.name = "ミナト";
		h1.hp = 100;
		
		Hero h2 = new Hero();
		h2.name = "ミナト";
		h2.hp = 100;
		
		if(h1.equals(h2)==true) {
			
			System.out.println("同じ内容です");
			
		}else {
			
			System.out.println("違う内容です");
		
		}
	
		System.out.println(h1.hp);
		System.out.println(Hero.money);
		
		
	}

}
</div>
<div class="11月25日">
	package chap15;

public class Main {

	//文字列の情報を処理する様々な方法を総称して、文字列処理やテキスト処理といいます。
	//Stringクラスに備わる文字列調査のメソッド
	//内容が等しいか調べるpublic boolean equals(Object o)
	//大文字、小文字を区別せず内容が等しいか調べるpublic boolean equalsignoreCase(String s)
	//文字列長を調べるpublic int length()
	//空文字か（長さが0か）を調べるpublic boolean isEmpty()
	//文字列の内部から、別の文字列（または文字）を探すためのメソッド
	//含まれるか否かだけを判定するもの
	//文字列のどこに含まれているかという位置情報を返すもの
	//一部に文字列ｓを含むかを調べるpublic boolean contains(String s)
	//文字列ｓで始まるかを調べるpublic boolean startsWith(String s)
	//文字列ｓで終わるかを調べるpublic boolean endsWith(String s)
	//文字ｃｈ（または文字列str）が最初に登場する位置を調べるpublic int indexOf(int ch),public int indexOf(String str)
	//文字ch(または文字列str)を後ろから偏差くして最初に登場する位置を調べるpublic int lastIndexOf(int ch),public int lastIndexOf(String str)
	//引数で指定した文字列（部分文字列）がある文字列のどこに登場するかを探すためのメソッドもある
	//文字列の先頭位置を0として部分文字列が見つかった場合、その位置を、見つからない場合、-1を返します。
	//文字列の一部を別の文字列（または文字）として切り出すメソッドも準備されています。
	//指定位置の一文字を切り出すpublic char charAt(int index)
	//指定位置から始まる文字列を任意の長さだけ切り出すpublic String substring(int index),public String substring(int index,int endIndex)
	//どのメソッドでも先頭文字は0から始まることに注意
	//substring(a,b)はa<=x<bなので最後の文字は含まれない
	//大文字を小文字に変換するpublic String toLowerCase()
	//小文字を大文字に変換するpublic String toUpperCase()
    //前後の空白を除去するpublic String trim()
	//文字列を置き換えるpublic String replace (String before,String after)
	//全角スペースは除去されない
	//StringBuilderクラスを用いた連結です。stringbuilderインスタンスは内部に連結した文字列を蓄えるメモリ領域を持っている
	//appendメソッドを呼んでバッファに文字列を追加していく（必要に応じた回数を呼び出す）
	//最後に1回だけtoString()を呼び、完成した連結済みの文字列を取り出す。
	//stringインスタンスが保持する文字列情報は、インスタンス化した際に初期化され以後２度と変化することはない。
	//stringクラスに限らず、インスタンス化の後に内容が絶対に変化しないように設計されたクラスのことを不変であるといいます。
	//不変なクラスは、参照やスレッドという技術に関連したある種の複雑な不具合が原理的に起こりえないという特徴がある
	//以上の理由からstringクラスはあらゆるクラスから採用されます。
	//+による連結が行われた瞬間、古いインスタンスは捨てられ、連結後の情報を持つ新しいインスタンスがnewにより生成され格納されます
	//つまり、+演算子による数万回の文字列連結は、内部で数万回newすることを意味する
	//newによるインスタンス生成は、計算などに比べてJVMに大きな負荷がかかる処理なので、可変なクラスとして設計されています。
	//一方、stringbuilderは可変なクラスとして設計されているので、append（追加）メソッドの呼び出しのたびにnewを行うことなくバッファを拡大しながら新たな文字列を追記していく設計となっているため高速なのです
	//char型は文字コードで記録されている基本型なのでint型への変換ができる
	//プレイヤー名の条件
	//Stringクラスのmatchメソッドを用いることで複雑だったメソッドが非常にシンプルになっている	
	//引数で与えている[A-Z]{A-Z0-9}{9}という文字列は、文字列パターンまたは単にパターンといわれる
	//文字列の形式的な条件を正規表現という文法に従って記述したもの
	//matchメソッドのように文字列がパターンに従った形式を満たしている（マッチするか）を照合する処理のことをパターンマッチング
	//通常の文字：その文字でなければならないs.match("Java")
	//ピリオド：任意の一文字であればよいs.match("J.va")
	//アスタリスク：直前の文字の0回以上の繰り返し"あいうxx019".matches(".*")
	//指定回数の繰り返しhel{3}oというパターンは"HELLO"
	public static void main(String[] args) {
		
		String s1 = "すっきりjava";
		String s2 = "Java";
		String s3 = "java";
		
		if(s2.equals(s3)) {
			
			System.out.println("s2とs3は等しい");
			
		}
		if(s2.equalsIgnoreCase(s3)) {
			
			System.out.println("s2とs3はケースを区別しなければ等しい");
			
		}
		
		System.out.println("s1の長さは"+s1.length()+"です");
		
		if(s1.isEmpty()) {
			
			System.out.println("s1は空文字です");
			
		}
		
		String s4 = "Java and JavaScript";
		
		if(s4.contains("Java")) {
			
			System.out.println("文字列s4は、Javaを含んでいます。");
			
		}
		if(s4.endsWith("Java")) {
			
			System.out.println("文字列s4はJavaが末尾にあります");
			
		}
		
		System.out.println("文字列s4で最初にjavaが登場する位置は"+s4.indexOf("Java"));
		
		System.out.println("文字列s2で最後にjavaが登場する位置は"+s4.lastIndexOf("Java"));
		
		String s5 = "Java programming";
		
		System.out.println("文字列s1の4文字目以降は"+s5.substring(3));
		
		System.out.println("文字列s5の4～8文字目は"+s5.substring(3,8));
		
		StringBuilder sb = new StringBuilder();
		
		for(int i = 0; i < 100; i++) {
			
			sb.append("Java");
			
		}
		
		String s = sb.toString();
		
		System.out.println(s);
		
		
		String str5 = "こんにちはjava";
		
		char[] date1 = str5.toCharArray();
		//byte[] date2 = str5.getBytes("utf-8");
		byte[] date3 = str5.getBytes();
		
		System.out.println(date1);
		System.out.println(date3);
	
	
	}

}

</div>
<div class="11月26日">
	package chap15;

public class Main {

	//{n}は直前の文字のn下位の繰り返し
	//{n,}直前の文字のn回以上の繰り返し
	//{n,m}直前の文字のn回以上のm回以下の繰り返し
	//?直前の文字の0回または1下位の繰り返し
	//+直前の文字の1回以上の繰り返し
}
<>
<h1>今日のjava</h1>

 <div class="11月6日">
    package chap02;

    public class Code_2_1_2_15 {

	    public static void main(String[] args) {

		    int a;
    		int b;//①変数宣言の文
    		a = 20;//②計算の文（代入）
    		b = a + 5;//③計算の文（足し算して代入）。式と呼ぶ。
    		System.out.println(a);
            System.out.println(b);

            /*
              オペランド…上の「a」「b」「5」のことをいう。
              演算子………上の「+」「＝」のことをいう。
              ↑の全ての式はこの2つの要素だけで構成されています。
              リテラル……オペランドの中でも数字「5」や文字列「Hello World」など、ソースコードに
                          記述されている具体的な値のこと。データ型を持っています。
            */

            System.out.println("私の好きな記号は二重引用符(")です");//javaは前から文字列を認識するためエラーになる"

            System.out.println("私の好きな記号は二重引用符(\")です");
            /*
              \によってダブルクォーテーションは文字としてみなされる。
              \100を表示する場合、￥￥と二つつける。
             */
	    }

    }
 </div>
 <div class="11月7日">
          /*
          ★演算子は周囲のオペランドの情報を使って計算を行い、それらオペランドを巻き込んで結果に化ける。（置き換わる）
          ★式に演算子が複数ある場合は、javaで定められた優先順位の高い演算子から順に評価される。
          ★式の中に同じ優先順位グループに属する演算子が複数ある場合、演算子ごとに決められた「方向」から順に評価される。
          ★3.2/2＝1.6、9/2=4 「/」整数なのでint型。小数点は使えない。小数点の計算をする場合、9.0/2のようにどちらかの
          　オペランドを小数にする。小数にするとダブル型になり、結果が小数で表示される。
          代入演算子…右オペランドの内容を左オペランドの変数に代入する演算子。
          　　　　　　ex)
                         int a = 10
                         a += 5 (a = a+5)
                         a = 15
          単項演算子…++a、++bでは他の演算子と一緒に利用すると微妙に違っていて、実行されたときに表示されるものが変わる。
         */

        double d = 3;//double型変数にint型の3を代入できてしまう。
        String s = "ベスト" + 3;//String型とint型を連結出来てしまう。
        //Javaが式を評価する過程で自動的に型を変換しているからです。
        //ある型で宣言された変数には、その型の値しか代入出来ません。
        //値が自動的に箱の型に変換されて代入されます。
        //型のメモリーが小さいものから大きなものは変換できるが、逆は出来ない。
        float f = 3;//float型の変数にint型を代入
        double d = f;//double型の変数にfloat型を代入
        System.out.println(f);
        System.out.println(d);
        //意味的に「小さな型」の値を「大きな型」の箱に代入する場合、代入される値が代入先の変数の型
        //に自動的に変換されてから代入が行われる
        int i = 3.2;//小数はint型より大きいメモリーが必要なため代入できない
        //byte型やshort型の変数に対して、実害がない範囲でint型リテラルを代入することが例外で認められている。
        int age = (int)3.2;//強制的な型変換（キャスト変換）。3.2をintに型変換して代入せよという意味。
        System.out.println(age);
        //実行結果はint型はあくまで整数型のため小数点以下がなくなる。
        //キャスト演算子は、元のデータの一部を失ってもデータを強制的に変換しようとするため、はみ出た部分は捨てられてしまい、情報の欠損が発生します。
        //異なる型で演算を行った場合は、意味的に大きな型に統一されてから演算が行われる。
        double d = 8.5/2;//2(int型)を2.0(double型)に変換。
        long l = 5 + 2L;//5(int型)を5L(long型)に変換。
        String msg = "私の年齢は" + 23;//23(int型)が”23”(string型)に変換されて連結される。
        //命令実行の文とは…javaが準備してくれている様々な命令を呼び出すための文です。
        String name = "すがわら";//①変数宣言の文
        String message;//①変数宣言の文
        message = name + "さん、こんにちは";//②計算の文
        System.out.println(message);//命令実行の文。(message)は引数またはパラメーター。
        System.out.println();//printlnのlnはline。一行で表示される。
        System.out.print();//続けて表示される。
        int a = 5;
        int b = 3;
        int m = Math.max(a,b);//引数を比較してどちらか大きい数字がmに入る
        String age = "31";
        int n = Integer.parseInt(age);//string型をint型に変換する。
        int r = new java.util.random().nextInt(90);//0~89までの90通りの乱数
        String name = new java.util.Scanner(System.in).nextLine();//キーボードから文字列を受け取る
        int age = new java.util.Scanner(System.in).nextInt();//入力から文字列を受け取る。

 </div>
 <div class="11月8日">
       制御構造…文を実行させる順番のことをいう。（または制御フロー）
    		Thread.sleep(0);…1/1000秒で指定する。1000/1000=1秒。1秒間処理を止める。
    		制御構文…if文やwhile文のような制御構造を表す文のことを言う。
    		ブロック…ブロックとは複数の文をひとまとまりとして扱うものです。
    		　　　　　ブロック内が一文しかない場合、なみかっこを省略していい。
    		     　　　ブロック内で宣言した変数は、そのブロックが終わると同時に消滅します。
    		スコープ…変数が利用可能な範囲。
    		関係演算子…「＝＝」、「＞」など評価されて化けるという特性がある。
    		　　　　　　具体的には関係が成立するならtrue(真)に、そうでないならfalse(偽)に化ける。
    		String strA = "夕日";
    		メモリーの中の例3000番地に記録される。
    		strAに3000番地を記録して実際の3000番地に「夕日」を記録する。
    		strAが呼び出された場合、strAに記録されている番地から参照して呼び出す。
    		int型は変数に直接代入された数字が記録される(基本型)が、String型など頭文字が大文字のデータ型は記録されている番地
    		を参照してその番地から呼び出す（参照型）。
    		String strB = "夕日";

    		strA == strB
    		両方とも番地で登録されているため同じものだと認識されるが

    		String strC = new java.util.Scanner(system.in).nextLine();

    		strA == strB
    		の場合、newで強制的に新しいメモリー用域に記録されるため、別の番地が登録される。
    		そのため、同じ文字列でも別の文字列と認識されてしまう。

    		Str.equals…番地情報のひかくではなく、一文字一文字メモリーに記録されている文字を参照しているため、
    		　　　　　　同じ文字列か正確に出せる、

    		論理演算し…「＆＆」や「｜｜」のこと

    		switch文とは…すべての条件式が「変数＝＝値」や「変数＝＝変数」のような一致するかを比較するしきになっていて
    		　　　　　　　比較する値が小数や真偽値ではない。
    		       　　　条件に一致するcaseラベルまで処理をジャンプさせる命令。
    		          　　break文で明示的に「処理を中断してswitch文をぬける」という指示を出す。
    		break文…そのブロックをぬけるという意味。

    		前置判定…ブロックを実行する前に条件判定を行う。
    		　　　　　なので、初めから条件式の判定がfalseだった場合、一度もブロックが実行されない。
    		後置判定…ブロックを実行した後に条件判定を行う。
    		　　　　　　最低一回はブロックを実行する。
    		for文…繰り返しが始まるにあたり最初に一回だけ実行される文を初期化処理という。
    		　　　ここで使う変数を通常ループ変数という。
    		for(①初期化処理；②繰り返し条件；③繰り返し次処理)
    	　　ループ変数の名前は自由だが、一度宣言している変数は使えない。
    	  　変数はブロックの外に行くと消滅してしまう。

    	   多重構造のことをネストや入れ子という。

    	   continue文…今の周回を中断して同じ繰り返しの次の周回に進む。

    	   無限ループ…永久に繰り返しをし続ける制御構造のこと
</div>
<div class="11月10日">
        package chap04;

      　public class chap04_4_1_4_19 {

      	public static void main(String[] args) {

      		int sansu = 20;
      		int kokugo = 20;
      		int rika = 20;
      		int eigo = 20;
      		int syakai = 20;

      		int sum = sansu + kokugo + rika +syakai +eigo;

      		int avg = sum/5;

      		System.out.println("合計点:"+sum);
      		System.out.println("合計点:"+avg);

      		/*
      		  テスト科目が増えるたびに、それをコードに追加しなければならない
      		  まとめて処理ができない
      		  私たちは一組として計算できるが、javaは一つの箱として見ているのでまとめて見ることができない
      		*/

      		/*
      		  ある一定のルールにしたがってデータを格納する形式をデータ構造という
      		  その代表的なものが配列です。
      		  配列(array)とは同一種類の複数データを並び順で格納するデータ構造です。
      		  一つを要素年、配列の各要素には同一種類のデータしか格納できない。
      		  要素には番号がついていてそれを添え字（index）という。
      		  0~から始まる
      		*/

      	}

      	public static void code_1() {

      		int[] scores;//配列変数の宣言
      		scores = new int[5];//要素の作成と代入

      		/*
      		  int型の配列を５つ生成する(5つメモリーを準備する)
      		  int型は参照型ではなく、基本型のため普通はそのままメモリーに記録されるが
      		  配列のためString型のように参照される。
      		*/

      	}

      	public static void code_2() {

      		int[] scores = new int[5];//配列変数の宣言と要素の作成と代入を同時に行う

      		int num = scores.length;//配列の変数名.lengthで配列の要素数の取得
      		System.out.println("要素の数:"+num);

      	}

      	public static void code_3() {

      		int[] scores;
      		scores = new int[5];
      		scores[1] = 30;//2つめの要素に30を代入

      		System.out.println(sscores[1]);

      	}

      	public static void code_4() {

      		int x;

      		System.out.println(x);//xに何も値がない＝初期化をしていないためエラーがでる

      	}

      	public static void code_5() {

      		int[] scores = new int[5];

      		int[] scores1 = new int[] {20,30,40,50,80};//省略方法
      		int[] scores2 = {20,30,40,50,80};//省略方法2

      		System.out.println(scores[0]);

      		/*
      		  特に代入をしていなくても配列を作った時点で初期化され
      		  初期値の「0」の数字が入る。
      		  boolean型はfalse、string型はnullが初期値。
      		*/

      	}

      	public static void code_6() {

      		int[] scores = {20,30,40,50,80};
      		int sum = scores[1] + scores[2] + scores[3] + scores[4] + scores[5];
      	    int avg = sum / scores.length;

      		System.out.println("合計点:"+sum);
      		System.out.println("平均点:"+avg);

      		//要素数の添え字は0～4なのでコンパイルエラーとなる。

      	}

      	public static void code_7() {

      		int[] scores = {20,30,40,50,80};
      		for (int i = 0;i < scores.length; i++) {

      			System.out.println(scores[i]);//ループのたびにiの値が0～4で変化する

      		}

      	}

      	public static void code_8() {

      		int[] scores = {20,30,40,50,80};
      		int sum = 0;//集計結果を入れるための変数を初期化して準備
      		for (int i = 0;i < scores.length; i++) {

      			sum += scores[i];//1科目ずつ変数sumに合算する

      		}

      		int avg = sum /scores.length;

      		System.out.println("合計点:"+sum);
      		System.out.println("平均点:"+sum);

      	}

      	public static void code_9() {

      		int[] scores = {20,30,40,50,80};
      		int count = 0;//変数宣言と初期化
      		for (int i = 0; i < scores.length; i++) {

      			if(scores[i]>=50) {
      				count++;
      			}

      		}
      		System.out.println("50点以上の科目の数は:"+count);
      	}

      	public static void code_10() {

      		int[] seq = new int[10];

      		for(int i = 0; i< seq.length; i++) {

      			seq[1] = new fava.util.Random().nextInt(4);

      		}

      		for(int i = 0; i < seq.length; i++ ) {

      			switch([seq[i]]) {

      			case0:
      				System.out.println("A");
      			    break;
      			case1:
      			    System.out.println("T");
      			    break;
      			case2:
      			    System.out.println("G");
      			    break;
      			case3:
      			    System.out.println("C");
      			    break;

      		    }

      		}

      		char[] base = {'A','T','G','C'};
      		System.out.println(base[seq[i]]+"");

      		int vaseType = seq[i];//i番目の数値を取得
      		char baseChar = base[baseType];//数値に対応する記号を取得
      		System.out.println(baseChar+"");//記号を画面に表示
      	}

      	public static void code_11() {

      		int[] scores = {20,30,40,50,80};

      		for(int i = 0; i< scores.length; i++) {

      			System.out.println(scores[i]);

      		}

      		for(int value : scores) {
      			System.out.println(value);
      		}
      		//任意の変数名に指定した変数に配列の要素の内容が格納されます。
      		//これを拡張for文という。

      	}

      	public static void code4_15() {

      		int[] arrayA = {1,2,3};
      		int[] arrayB;

      		arrayB = arrayA;//住所番号を代入している

      		arrayB[0] = 100;

      		System.out.println(arrayA[0]);

      		/*
      		最初の要素のアドレスが変数に記録されている
      		住所番号を代入しているので参照先の値が一緒になっている
      		先頭の番号がわかればあとはインデックス番号で呼び出せる
      		int[] scores = new int[5]のメモリー上の処理
      		①int型の要素を5つ持つ配列がメモリ上に作成される。
      		②int[]型の配列変数scoreがメモリ上に作成される。
      		③配列変数scoreに配列の戦闘要素のアドレスが記録される。
      		プログラムからscores[n]と指定されたら
      		①scoresから番地(8832)を取り出し、配列(先頭要素)をみつける。
      		②見つけた配列の先頭要素からn個後ろの要素の区画を読み書きする。
      		*/
      	}

      	public static void code_11() {

      		boolean judge = true;

      		if (judge == true) {

      			int[] array = {1,2,3};

      		}
      		/*
      		ifブロック内で配列を宣言しているので
      		ブロックを抜けたら消滅する。
      		一方で、newで確保された３つの要素は普通の変数ではないので、ブロックが
      		終了しても寿命は迎えません。
      		メモリ内のごみとなってメモリを圧迫してしまう。
      		javaには、ガベージコレクションという仕組みがあり、
      		度の変数からも参照されなくなったメモリ領域を自動的に探しだして片づけてくれます。
      		*/
      	}

      	public static void code_12() {

      		int[] array = {1,2,3};
      		array = null;
      		array[0] = 10;
      		/*
      		配列変数arrayにnullを代入すると住所番号が空になり、
      		値の参照先がなくなった状態になる。
      		このことを参照を切るという。
      		①int[]型などの参照型変数に代入すると、その変数はなにも参照しなくなる。
      		②int型などの基本型変数には代入することはできない。
      		*/

      	}

      }

</div>
<div class="11月11日">
    package chap05;

        import java.net.http.HttpRequest.BodyPublisher;
        import java.security.PublicKey;

        public class code_5_1_5_14 {

        	public static void main(String[] args) {

        		/*
        		メソッドとは、複数の文をまとめ、それを1つの処理として名前をつけたもので部品の最小単位になります。
        		メソッド利用によるメリット
        		プログラムの見通しがよくなり、全体を把握しやすくなる。
        		機能単位に記述するため、修正範囲を限定できる。
        		同じ処理を一つのメソッドにまとめることで、作業効率が上がる。
        		メソッドを作成することをメソッドの定義という。
        		*/

        	}

        	public static void hello() {

        		System.out.println("湊さん、こんにちは");

        		//hello()はメソッド名です。｛｝のなかはメソッドブロックといい、hellメソッドを呼び出したときに実行される。
        		//メソッドを使用することをメソッドを呼び出すといいます。
        		//メソッド名は自由だが、基本的に動詞を使用する。

        		/*
        		mainメソッド内
        		System.out.println("メソッドを呼び出します");
        		hello();
        		System.out.println("メソッドを終了します");

        		helloメソッドを呼び出していてメソッドは自動的には動かない。
        		*/

        	}

        	public static void methodB () {

        		System.out.println("methodB");

        	}

        	public static void methodA() {

        		System.out.println("methodA");
        		methodB();

        	}
        	/*
        	ソースコード内に定義された各メソッドは同列の存在です。
        	プログラムは必ずmainメソッドから動き始める。
        	new java util Scanner(System.in).nextInt();はスキャナークラスのnextIntメソッドを
        	呼び出しているので「()」がある。
        	*/


        	public static void mein(String[] args) {

        		System.out.println("メソッドを呼び出します");

        		hello("湊");
        		hello("明日香");
        		hello("菅原");

        		System.out.println("メソッドの呼び出しが終わりました。");

        	}

        	public static void hello(String name) {

        		System.out.println(name+"さん、こんにちは");

        	}

        	public static void mein(String[] args) {

        		add(100,20);//100と20を渡してaddメソッドを呼び出す
        		add(200,50);//200と50を渡してaddメソッドを呼び出す

        	}

        	public static void add(int x,int y) {//int型を使っているため数字以外をうけつけない。変数2つのため使える数字も2つ。

        		int ans = x + y;
        		System.out.println(x + "+" + y + "=" + ans);

        	}

        	//渡す値、受け取る変数ともに「引数」だが、渡す値のことを実引数、受け取る変数のことを仮引数と呼びます。

        	public static void meein(String[] args) {

        		int x = 100;
        		int y = 10;
        		add();

        	}

        	public static void add() {

        		int ans = x + y;//ブロック外で宣言されているため変数は消滅してしまい、値が入らない。
        		System.out.println(x + "+" + y + "=" + ans);

        	}

        	//メソッド内で宣言した変数をローカル変数と呼び、別のメソッドに属する同名のローカル変数とはまったく別物です。
        	//異なるメソッドに属するローカル変数は、お互いに独立していて無関係である。

        	public static int add(int x,int y) {

        		int ans = x + y;
        		return ans;//型を一致させる。何も戻さない場合はvoidを指定します。
        		return文はメソッドの終了も行うのでreturnの後にコードを書くとコンパイルエラーになり、到達不能コードを教えてくれる。4221
        	}

        	public static void main(String[] args) {

        		int ans = add(100,10);
        		System.out.println("100+10="+ans);

        	}

    }

</div>
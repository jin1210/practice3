likeによるあいまい検索とは
sqlには like句を使ったあいまい検索の構文があります。

~where 列名　like '%検索値%'
~where 列名　like '検索値_'

%→0文字以上の任意の文字列
_→任意の1文字

同様のことをrailsで実現するためには、whereメソッドにsqlのlike句で
検索条件を記述します。

モデルクラス.where("列名 like ?", "%値%")　値（文字列）を含む
モデルクラス.where("列名 like ?","値_") 値（文字列）と末尾の一文字

「？」はプレースホルダというもので、第二引数の値を「？」へ置き換えるための目印です。

sqlインジェクションなどのセキュリティリスクを防ぐ働きもあります。


where句とは、テーブルデータの検索条件を指定するためのSQL構文です

where句を使う目的は、データの検索対象を絞り込むためにselect文と組み合わせたり、
データの更新対象を指定するためにupdate文と組み合わせて使います。

select文と組み合わせた場合の構文は次の通りです。

select
 フィールド名
from
 テーブル名
where
 演算子を使って検索条件を指定
end

emp_no(従業員番号)が10003以下のデータを抽出するSQLは次の通りです。

select
 *
from
 employees
where
 emp_no <= 10003

AかつBを指定するAND演算子

select
 *
from
 employees
where
 emp_no >= 10003 AND
 emp_no < 10005

 select
  *
 from
  employees
 where
  emp_no between 10002 and 10004

いずれかの条件に一致するレコードを検索するIN演算子

select
 *
from
 employees
where
 emp_no in (10001,10003,10005)


文字列の部分一列を検索するlike演算子

select
 *
from
 employees
where
 first_name like 'kyo%'
 
 eachメソッドは、主に配列の要素文の処理を繰り返し行いたい場合に使用する
 メソッドです。配列を指定してeachメソッドを実行すると、配列のインデックス
 番号0から順番に繰り返し処理が実行されます。
 
オブジェクト.each do |変数|
　繰り返し処理
end

オブジェクト.each { |変数|
　繰り返し処理
｝

ブロック内に指定した変数は、配列で取得するときの変数名を指定します。

配列とは、rubyの任意のオブジェクトを複数まとめて同じように取り扱うためのオブジェクト
です。配列のリテラル表現は、「」で囲み、カンマ「、」区切りで記述します。

配列のリテラル表現とは、rubyのコード中で配列とその内容を定義するためのコードによる
配列の表現です。配列には、任意のrubyオブジェクトを要素として持つことが可能です。

はいれつのなかにハッシュを入れることや、配列の中にさらに配列を入れる入れ子の配列
を作ることもできます。

文字列の配列
["samurai","ruby","rails","python"]

数値の配列
[50,-60,700,8000]

ハッシュの配列
[{ruby:80},{python:70},{swift:60}]

配列の入れ子
["samurai",["ruby","rails"],"python"]

オブジェクトが混在した配列
[50,"samurai",["ruby","rails"],"python",{ruby:810},80000]

任意のオブジェクトを入れることができるということは数値やハッシュ、配列などを配列に
入れることも可能だということです。配列の基礎については

配列の初期化は、空の配列のリテラル表現を代入することで可能です。
また、arrayクラスのnewメソッドにより配列を初期化することもできます。

初期化後の配列は通常、空の配列です。newメソッドに配列のサイズを指定して
任意の要素数の配列を初期化できます。

また、newメソッドに配列のサイズと要素の初期値を指定して任意の要素数で同じ初期値
を持った要素を持つ配列を初期化することもできます。

初期化
array = []
puts "NO.1" + array.to_s

または
array = array.new()
puts "no.2" + array.to_s

サイズを指定して初期化
array = array.new(3)
puts "no.3" + array.to_s

サイズと要素を指定して初期化
array = array.new(3,"samurai")
puts "no.4" + array.to_s

配列の要素を更新するには、配列の入った変数に[]演算子で既存のインデックスを指定し、
それに対し値を代入します。例えば、array変数のインデックス1番目の要素を更新するには、
以下のようなコードを書きます。

array[1] = 値

array = ["samurai","ruby","rails","python"]

一番目の要素は"ruby"
puts "no.1" + array[1].to_s

一番目の要素を更新
array[1] = "swift"
puts "no.2" + array[1].to_s

array
puts "no.3" + array.to_s

配列の要素を取得するには、配列の入った変数に対して[]演算子にインデックス(添え字)を
指定します。
例えば、array変数のインデックス0番目の要素を取得するtには、以下のようなコードを
書きます。

array[0]

array = ["samurai", "ruby", "rails" ,"python"]

puts "no.1" + array[0].to_s
puts "no.2" + array[1].to_s
puts "no.3" + array[2].to_S
puts "no.4" + array[3].to_s

配列に要素を追加するには、配列の入った変数に[]演算子で存在しないインデックスを
指定し、それに対し値を代入します。

また、簡単に配列を要素を追加する方法として、配列のpushメソッドがあります。
pushメソッドは、配列の末尾に指定した値を追加します。

array = ["samurai","ruby","rails","python"]

puts "no.1" + array[4].to_s

代入
array[4] = "java"

代入の結果を表示
puts "no.2" + array[4].to_s

配列全体を表示
puts "no.3" + array.to_s

pushメソッドでも追加できる
array.push("PHP")
puts "no.4" + array.to_S


配列の要素を更新するには、配列の入った変数に[]演算子で既存のインデックスを
指定し、それに対し値を代入します。例えば、array変数のインデックス1番目の
要素を更新するには、

配列の要素を排除するには、配列のdeleteメソッドを使用します。deleteメソッドに値
を指定すると、配列中の同じ値をもつ要素を排除します。

また、配列に[]演算子でインデックスの範囲を指定し、それに空の配列リテラル[]
を代入することで、指定したインデックスの範囲分だけ配列から要素を削除できます。

array = ["samurai","ruby","rails","python","ruby"]
puts "no.1" + array.to_S

同じ要素をすべて削除
array.delete("ruby")
puts "no.2" + array.to_s

範囲を指定して削除出来る
array = ["samurai","ruby","rails","python"]

インデックスの1から2個の要素を削除
array[1.2] = []
puts "no.3" + array.to_s

配列の要素数を取得するには、sizeメソッドを実行します。また、sizeメソッド
のエイリアスであるlengthメソッドでも、配列の要素数を取得できます。

さらにcountメソッドでも配列の要素数を取得できます。
countメソッドの引数に値を指定すると、配列中で同じ値を持つ要素数を取得できます。

array = ["samurai","ruby","rails","python","ruby"]

puts "no,1" + array.size.to_s

puts "no.2" + array.length.to_s

puts "no.3" + array.count.to_S

puts "no.4" + array.count("ruby").to_s

配列の末尾に要素を一つ追加するにはpushメソッドを使用します。
対して配列の末尾から要素を1つ削除するにはpopメソッドを使用します。

配列の先頭に要素を一つ追加するにはunshiftメソッドを使用します。
対して配列の先頭から要素を1つ削除するにはshiftメソッドを使用します。

array = ["samurai","ruby","rails"]

pushは要素の配列の末尾への追加
array.push("swift")
puts "no.1" + array.to_s

popは要素の配列の末尾からの削除
array.pop
puts "no.2" + array.to_s

unshiftは要素の配列の先頭への追加
array.unshift("scala")
puts "no.3" + array.to_s

shiftは要素の配列の先頭からの削除
array.shift
puts "no14" + array.to_S

配列のsort,short_byメソッド
配列の要素を、値の昇順に並び替えるにはsortメソッドを使用します。
配列の要素を、好きな順番で並び替えるにはsortメソッドにブロックを与えます。

ブロックのブロック変数に配列を並び替えるために比較する2要素wが
与えられます。この2要素の比較基準を変えることで、好きな順番でsortできます。

array.sort {|a,b|
 b <=> a
 }

上記コードで、ブロックの返り値は、「b<=>a」です。「b<=>a」は、bがaより
大きいときに1を返し、bがaより小さいときに-1を返します。bとaが等しいときは0
を返します。

この返り値により、sortメソッド中でbが大きいときにbをそのままの順番に置いたままにし、
bが小さいときにbとaの順番を入れ替えます。bとaが等しいときには何もしません。
このsortの挙動により、結果的に配列が降順に並び替えられます。

この例はsortの一例ですが、例えばa<=>bとした場合は、配列が昇順に並び替えられま鵜s。

単にsortメソッドを呼び出せば昇順ソートが行われる
array = [3.2.4.8.2.10.1.9.6.7]
puts "no.1" + array.sort.to_s

ブロック変数にsort用の2要素を受け取れば、その比較結果をsortの基準にする
ここでは、b<=>aにより、降順sortになる。

また、sortメソッドにブロックを渡すことにより、好きな順番で配列を並び替えるkとが
出来ます。別の方法で配列を好きな順番で並び替える方法として、sort_byがあります。

sort_byでは並び替える要素をブロック引数として受け取ります。
そのブロックの返り値で、並び替える基準となる値を指定することで、
その基準で並び替えられま鵜s。

array = ["samurai","ruby","rails","php"]
sort_byのブロックの返り値がsort基準になる
ここでは文字列の長さをsort基準にしている
puts "no,1" + (array.sort_by {|a| a.size}).to_s

いじょうのように、sort_byのブロック引数aに対し、a.sizeと文字列長をブロックの返り値
に指定することで、配列の並び替えの基準を文字列名が昇順に指定まs。

配列のeachメソッド

配列の要素を1つ1つずつループさせて、各ループでブロックを実行させる方法としてeach
メソッドがあります。eachメソッドは配列の要素数分、繰り返し実行されます。

その際、eachメソッドのブロックのブロック変数に、配列の一つの要素が与えられます。
この機能を使って、配列お要素を1つ1つputsメソッドで出力した例が、以下のサンプルコードです。

array = ["samurai","ruby","rails","swift","java","php"]
cnt = 1
array.each {|item|
 puts "no.#{cnt}" + item.to_s
 cnt += 1
}

以上のように、eachメソッドにより配列の要素が1つ1つぼろっくのブロック
引数に与えられ、ブロックが各要素文だけ実行されます。

配列とは、データをたくさん詰められる箱のようなものです。そしてそのデータの一つ一つを要素を言います。

fruits = ["apple","berry","banana"]

という配列においては、配列名はfruitsで要素はapple berry banana になります。

配列の追加

fruits = ["apple","berry","banana"]

fruits.push("lemon")

puts fruits

fruits = ["apple","berry","banana"]

fruits << "lemon"

puts fruits

配列の削除

fruits = ["apple","berry","banana"]

fruits.delete("berry")

puts fruits

オブジェクト.each do |変数|
実行する処理
実行する処理
end

fruits = ["apple","berry","banana"]

fruits.each do |hoge|　←each文を定義する(hogeは要素の中身全てを表す)

print hoge + ","　←要素の中身1つ1つに","をつけて出力させる

end

empty(配列が空かどうか調べる)

arr = []
p arr.empty?

array = [1.2.3]
p array.empty?

include(要素が含まれるか調べる)
array = [1.2.3]
p array.include?(3)

配列に指定した要素が含まれているか確認したいときはinclude?メソッドを使用思案す。
指定した引数が配列の要素に含まれていればtrue,含まれていない場合はfalseを
返します

any?(最低1つでも条件を満たすか調べる)
array = [1.2.3]
p array.any?{|a| a > 2}

all?

array = [1.2.3]
p array.all?{|a| a > 2}

配列の要素がすべて指定した条件に満たしているか確認したい場合はall?

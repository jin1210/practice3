%記法の本来の目的は、文字列に含まれる「’’」や「””」を「（）」などの
非英数字に置き換えて、「’’」や「””」に対するエスケープを省略するために利用する

％ｗ記法とは、文字列からなる配列を作成したいときに「[]」(ブランケット)や「””」
（ダブルクォーテーション）を省略して記述するためのrubyの構文です。

%w(文字列1

%w(文字列1　文字列2　文字列3…)

文字列間の空白は配列の要素の区切りとなります。

％ｗ記法を使うと、プログラムコードの可読性が良くなって、コーディングも簡単に
なるので、よく利用される書き方です。

%w記法を使って配列を作ってみる

％ｗ記法を使わない場合と、使う場合のコードの違いを比較して、どのように稼働区政
が良くなるかを確認してみましょう。

puts ["侍","ブログ","ruby","\"%w記法\""]

puts %w(侍　ブログ　ruby "%w記法")

%w記法は、%wと同様に空白区切りの文字列から配列を作成できます。

%w →　式展開なし
%W →　式展開あり

blog = "ブログ"
puts %W(侍 #{ブログ})

blog = "ブログ"
puts %w(侍 #{blog})

このように、前者の%Wは変数blogの値が配列に登録されて式展開することが確認できました


%記法または％Q記法は””（ダブルクォーテーション）の代替です。

％または％Q記法を使うと、文字列の中の「”」のエスケープを省略して文字列を作成
できるので、可読性を高めるために有効です。

puts "\"侍\" \"ブログ\""

puts %("侍"　”ブログ”)

％と％Ｑ同じ意味

％ｑ記法は「’’」（シングルクォーテーション）の代替です。
％ｑ記法を使うと、文字列中の「’」のエスケープを省略して文字列を作成できます。
「’’」と同様に式展開はしません。

puts '\'侍\' ブログ'

puts %q('侍'　ブログ)

%r記法を使うと、正規表現内にある「/」や「[」などの文字に対するエスケープを
省略し、プログラムコードの可読性を上げることができます。


/https:\/\/www.sejuku.net\/blog\//

%r記法を使って「！」を使ったコード

%r!https://www.sejuku.net/blog/!

%i記法は、%wと同様に空白区切りの文字列から配列を作成しますが、
こちらは配列の要素がシンボルになります。

％i　→　式展開あり
%I　→　式展開なし

%i記法を使って、次の2つのサンプルコード同じ結果を返すことを確認して
みましょう。

p [:samurai, :blog, :ruby]

p %i(samurai, blog, ruby)

matchメソッドは引数に正規表現を指定して、マッチした文字列を取得したいときに使用します。
オブジェクト名.match(/正規表現/)

正規表現は「//」でくくった中に記述します。

正規表現とは特殊文字を用いて文字列を表現するための手段で、プログラミングに
おいて文字列を検索するときによく使われます。

例えば、「samurai engineer」の文字列から「engineer」の部分のみ取得したい
場合は、正規表現として「/.*engineer/」と表現することで取得するtことが
できます。
matchめそっt度は正規表現のパターンにマッチした場合は配列を返し、一致しなかった
ばあいはnilを返します。

一致した文字列を取得する

ここでは、matchメソッドの基本的な使い方を見ていきましょう

文字列の中から、一致した文字列を取得するには以下のように記述します。

str = "appleorangemelon"

md = str.match(/orange/)

puts md[0]

このさんぷるでは「//」で文字列「orange」が存在するかmatchメソッドで確認を
おこない、一致した場合はその文字列を取得しています。

オブジェクトstrには文字列「orange」が存在するため、mdには一致した
文字列が格納されます。

部分一致した文字列を取得します。

部分的に文字列を検索したい場合は「*」を使用します。
「*」は検索文字列の前または後ろに「*検索文字列」のように検索文字列
を含む文字列を取得することができます。

string = "hello ruby!! hello rails!!"

md = string.match(/.*ruby!!/)

puts md[0]

文字列から数字のみを取得する

文字列から数字のみを取得したい場合、「/\d+/」のように指定します。

/\d+/という正規表現は、数字が一個以上並んでいる場合の文字列にマッチします。


str = "AAA-012-BBB".match(/\d+/)
p str[0]

str = "ABC-DEF-345".match(/\d+/)
p str[0]

str = "678-ABC".match(/\d+/)
p str[0]

一致した文字列の前後の値を取り出す

pre_matchでマッチした前の部分を取り出す
pre_matchメソッドを使用すると、マッチした文字列のより前の文字列を取得する
事が出来ます。

str = "rubyの勉強およびrailsの勉強をはじめましょう"

reg = /および/.match(str)

p reg.pre_match

post_matchマッチした後ろの部分を取り出す
post_matchメソッドを使用すると、マッチした文字列のより後ろの文字列を取得する
ことができます。

str = "rubyの勉強　及び　railsの勉強をはじめましょう"
reg = /および/.match(str)
p reg.post_match

「：」コロンはrubyにおいて、そのオブジェクトがシンボルであることを明示するための
記号です。

hash1 | {:ruby=>"rails",:python=>"django"}
hash2 | {ruby:"rails",python:"django"}

別にシンボルなんてものがなくても、文字列だけでいいじゃないかと思った方も
多いのではないでしょうか？

しかし、実はシンボルを使うと文字列で普通に定義した時と比べて、少しだけ
処理を高速化することができるからです。

まずシンボルはruby内部では数値として扱われるので、文字列と比べればメモリサイズ
が軽くなります。

さらに文字列は定義するごとに新しいオブジェクトを生成しますが、
シンボルはただ一つしか生成されず、その後呼び出したときはすべて一つから
値を参照します。

つまり、一つのオブジェクトだけで済むのでめもりを節約で起案す。
例えば、先ほどの例にあった：nameは法事の上では:nameですが、
rubyは：nameのことを数字だと思って扱っています。

ハッシュは、ブレース「｛｝」で囲み、カンマ「、」区切りで記述します。

キーの値のペアを「＝＞」で関連付けます。

キーと値には、数値や文字列を使うことができます。

{"name" => "samurai", "score" => 80}

{:name: => "samurai", :score => 80}

{name: "samurai", score: 80}

シンボルとは主に文字列にコロン記号「：」を前置きして定義したものです。

ただし、文字列を""で囲む必要はありません。

コロン記号「：」が、文字列記号「””」の代わりに、「これはシンボルだよ」とruby
に知らせています。

オブジェクトのclassメソッドは、そのオブジェクトがどのクラスに属しているかの
値を返します。

str = "string"
sym = :symbol

p str.class
p sym.class

シンボルはハッシュやアクセサ、ブロック引数などに使用されていますが、rubyを
学び始めたころはハッシュでのキーとしてよく使用します。

意味のある名前をキーに設定したいときにシンボルを使用します
キーにシンボルを使うことでプログラムの可読性があがり、コードの記述も簡単にすることが
できます。

文字列は文字列自体がデータをして扱われてますが、シンボルそのものは値を
持ちません。そのため、文字列そのもののデータを必要としない場合にシンボルが
使われています。

ruby内部の働きも文字列とは違います。

一度生成されるとシンボルがポインタとなり、複数回使用しても同じ領域を使用して
扱うことができます。
文字列を使用した場合は、宣言する度に文字列の領域が生成されます。

また、シンボルは銅市の名前であれば同じものとして扱われます。

逆に文字列は記述する度に生成され、同じ名前であっても内部では違うものとして
扱われます。

str1 = "samurai"
str2 = "samurai"
p str1.object_id
p str2.object_id
p str1.equal?(atr2)

sym1 = :samurai
sym2 = :samurai
p sym1.object_id
p sym
p '#{string}, python, java'